# ConcreteSyntax.org -----------------------------------------------------------

# Copyright (C) 2011, 2012 Guillem Marpons <gmarpons@babel.ls.fi.upm.es>
#
# This file is part of Crisp.
#
# Crisp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Crisp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Crisp.  If not, see <http://www.gnu.org/licenses/>.

#+PROPERTY: tangle yes
#+PROPERTY: exports code

This is an Org-mode file with Haskell code blocks that can be tangled
(in a literate programming sense) within Emacs with C-c C-v t.

Code blocks in [[*Tests][Tests]] can be loaded and executed in a GHCi session
with C-c C-c.

* Module declaration

#+begin_src haskell
  {-# LANGUAGE
    GADTs,
    FlexibleContexts,
    MultiParamTypeClasses,
    NoImplicitPrelude,
    NoMonomorphismRestriction,
    OverloadedStrings,
    Rank2Types,
    TypeOperators
    #-}
  
  module Crisp.ConcreteSyntax where
  
  import ClassyPrelude hiding (empty, readFile, writeFile)
  import Crisp.AbstractSyntax
  import Data.Char
      (isAsciiUpper, isAsciiLower, isDigit)
  import Data.Foldable
      (or, sequence_)
  import qualified Data.ListLike.Base as LL
      (ListLike(fromList, head, null, singleton, tail, toList))
  import qualified Data.ListLike.FoldableLL as LL
      (FoldableLL(foldl, foldr))
  import Data.String
      (String)
  import qualified Data.Text as TextPartialFunctions
      (head, tail)
  import Data.Text
      (cons, foldl, foldr)
  import Data.Text.IO
      (putStr, putStrLn, readFile, writeFile)
  import qualified Text.ParserCombinators.UU.BasicInstances as UU
      (pMunch, pTokenCost)
  import Text.ParserCombinators.UU.BasicInstances
      (createStr, Error(Inserted), Insertion(Insertion), pos, pSatisfy,
       pSym, Str(Str))
  import Text.ParserCombinators.UU.Core
      ((*>), (<$), (<$>), (<*), (<**>), (<*>), (<<|>), (<?>), (<|>),
       addLength, empty, IsLocationUpdatedBy(..), Nat(..), opt, P, parse,
       pEnd, pSymExt, pSwitch, Steps(Fail))
  import Text.ParserCombinators.UU.Derived
      (pChainr, pFoldr, pMany, pMaybe)
  import qualified Text.ParserCombinators.UU.MergeAndPermute as UU
      (Gram)
  import Text.ParserCombinators.UU.MergeAndPermute
      ((<||>), mkGram, mkParserM)
  import Text.ParserCombinators.UU.Utils
      (pAnySym, pLower, pSpaces, pUpper)
    
  import qualified Crisp.PrologSyntax as P
#+end_src


* Location datatype

We replace type synonims =Parser= and =ParserTrafo= from
=Text.ParserCombinators.UU.BasicInstances= to more specific versions
that use a special location datatype, =LineColPosIndent=, designed to
allow parsing based on layout (indentation).

#+begin_src haskell
  data LineColPosIndent = LineColPosIndent !Int !Int !Int !Int deriving Show
  
  instance LineColPosIndent `IsLocationUpdatedBy` Char where
     advance (LineColPosIndent line col pos indent) c
         | c == '\n' = LineColPosIndent (line + 1) 0         (pos + 1) indent
         | c == '\t' = LineColPosIndent line       tabCol    (pos + 1) indent
         | otherwise = LineColPosIndent line       (col + 1) (pos + 1) indent
         where tabCol = col + 8 - (col - 1) `mod` 8
  
  instance LL.FoldableLL Text Char where
      foldl = foldl
      foldr = foldr
  
  instance LL.ListLike Text Char where
      singleton = singleton
      head = TextPartialFunctions.head
      tail = TextPartialFunctions.tail
      null = null
  
  createStrIndent :: LL.ListLike s Char => s -> Str Char s LineColPosIndent
  createStrIndent inp = createStr (LineColPosIndent 0 0 0 (-1)) inp
  
  type Parser a = LL.ListLike s Char => P (Str Char s LineColPosIndent) a
  
  type ParserTrafo a b = Parser a -> Parser b

  type Gram a = LL.ListLike s Char => UU.Gram (P (Str Char s LineColPosIndent)) a
#+end_src


* Parsers for non-terminal symbols
  
#+begin_src haskell
  pModule :: Parser Module
  pModule = pMany pRelation
  
  pRelation :: Parser (Relation)
  pRelation = indented pRelation'
      where
        pRelation', pPred, pPred', pConcept, pRole :: Parser Relation
        pRelation' =     pPred
                     -- <|> pRule
        pPred    = atIndent (pK "pred") *> pPred'
        pPred'   =     pConcept
                   <|> pRole
        pConcept = uncurry ConceptDef <$> pConceptIdAndVars <*> pMeet
        pRole    = uncurry RoleDef    <$> pRoleIdAndVars    <*> pMeet
        pMeet :: Parser (Formula Filter)
        pMeet = atIndent (pK "meet") *> pFormulaFilter
  
  -- The following parser uses monadic bind, and consequently needs to
  -- declare its minimal (token = character) length.
  pConceptIdAndVars :: Parser (ConceptId, Formula Domain)
  pConceptIdAndVars = addLength 18 $ do
    v  <- pVar
    id <- pConceptId
    d  <- pOneDomain v
    return (id, d)
        where
          pConceptId :: Parser ConceptId
          pConceptId = pK "is" *> pLowerId
          pOneDomain, pOneDomain' :: Var -> Parser (Formula Domain)
          pOneDomain  var = atIndent (pK "vars") *> pOneDomain' var
          pOneDomain' var = indented $ mkParserM (pDomain var)
  
  -- The following parser uses monadic bind, and consequently needs to
  -- declare its minimal (token = character) length.
  pRoleIdAndVars    :: Parser (RoleId, (Formula Domain, Formula Domain))
  pRoleIdAndVars = addLength 26 $ do
    v1 <- pVar
    id <- pRoleId
    v  <- pVar
    v2 <- if v == v1 then do
                       -- If repeated var name, we append "@" to
                       -- it, a character not allowed in ordinary vars.
                       let msg = "different variable name"
                       c <- pSatisfy (const False) (Insertion msg '@' 0)
                       return (v ++ pack [c])
          else return v
    (d1, d2) <- pTwoDomains v1 v2
    return (id, (d1, d2))
        where
          pRoleId    :: Parser RoleId
          pRoleId    = flip (,) <$> (True  <$ pK "has" `opt` False) <*> pLowerId
          pTwoDomains, pTwoDomains' :: Var -> Var -> Parser (Formula Domain, Formula Domain)
          pTwoDomains  v1 v2 = atIndent (pK "vars") *> pTwoDomains' v1 v2
          pTwoDomains' v1 v2 = indented $ mkParserM $ (,) <$> pDomain v1 <||> pDomain v2

  pDomain :: Var -> Gram (Formula Domain)
  pDomain var = mkGram $ ConceptAssert <$> atIndent (ck var) <* pK "is" <*> pConceptDomain
      where ck = pK
  
  pFormulaDomain :: Parser (Formula Domain)
  pFormulaDomain = ConceptAssert <$> pVar <* pK "is" <*> pConceptDomain
  
  -- | Lines are conjunctively chained (association to the right). There
  -- are two kinds of line: assertion lines, and lines for
  -- (dis-)equality relations. Both kinds of line begin with a
  -- variable. (Dis-)equality relations cannot appear in an assertion
  -- line.
  pFormulaFilter :: Parser (Formula Filter)
  pFormulaFilter = indented $ pFoldr (And, Top) pLine
      where 
        pLine :: Parser (Formula Filter)
        pRHS  :: Parser (Var -> Formula Filter)
        pLine =     atIndent pVar <**> pRHS     -- pVar begins with upper case
                <|> pDisjunction                -- pDisjunction begins with "e"
        pRHS  =     pAsserts
                <|> pEqRelations
  
  pDisjunction :: Parser (Formula Filter)
  pDisjunction = Or <$> pLeftDisj <*> pRightDisj
      where
        pLeftDisj  :: Parser (Formula Filter)
        pRightDisj :: Parser (Formula Filter)
        pOtherDisj :: Parser (Formula Filter)
        pLeftDisj  = atIndent (pK "either") *> pFormulaFilter             -- Mut. rec.
        pRightDisj = atIndent (pK "or") *> pOtherDisj
        pOtherDisj = (Or <$ atIndent (pK "or")) `pChainr` pFormulaFilter  -- Mut. rec.
  
  -- | This parser receives a variable found at the beginning of a line
  -- (LHS variable) and parses a number of conjunctively chained
  -- (right-associative) assertions about this variable.
  pAsserts :: Parser (Var -> Formula Filter)
  pAsserts = (lineAnd <$ pO ",") `pChainr` pAssertElem
      where
        pAssertElem :: Parser (Var -> Formula Filter)
        pRoleId     :: Parser RoleId
        pAssertElem =     flip    ConceptAssert <$  pK "is" <*> pConceptFilter
                      <|> reorder RoleAssert    <$> pRoleId             <*> pVar
                      <|> reorder RoleAssertT   <$> pRoleId <*  pO "+"  <*> pVar
                      <|> reorder RoleAssertRT  <$> pRoleId <*  pO "*"  <*> pVar
        pRoleId     = flip (,) <$> isJust <$> pMaybe (pK "has") <*> pRoleName
        lineAnd  :: (Var -> Formula Filter) -> (Var -> Formula Filter)
                 ->  Var -> Formula Filter
        reorder :: (a -> b -> c -> d) -> b -> c-> a -> d
        lineAnd f g varLHS = And (f varLHS) (g varLHS)
        reorder f b c a = f a b c
  
  -- | This parser receives a variable found at the beginning of a line
  -- (LHS variable) and parses a number of (dis-)equalities with that
  -- variable. Any number of chained equalities is allowed (e.g. of
  -- three chained equalities: X = Y = Z), but a maximum of one explicit
  -- disequality can appear in a line. All the variables to the left
  -- (resp. right) of the disequality symbol are unified. All the
  -- variables to the left of the disequality symbol are declared
  -- different from all the variables to the right.
  pEqRelations :: Parser (Var -> Formula Filter)
  pEqRelations =     lineAnd <$> pEqualities <*> (pDiseqAndEqs `opt` const Top)
                 <|> pDiseqAndEqs
      where
        pDiseqAndEqs, pEqualities, pEquality :: Parser (Var -> Formula Filter)
        pDiseqAndEqs = diseqAnd <$ pO "/=" <*> pVar <*> (pEqualities `opt` const Top)
        pEqualities  = pO "=" *> (lineAnd <$ pO "=") `pChainr` pEquality
        pEquality    = flip (:=) <$> pVar
        diseqAnd :: Var -> (Var -> Formula Filter) -> Var -> Formula Filter
        lineAnd  :: (Var -> Formula Filter) -> (Var -> Formula Filter)
                 ->  Var -> Formula Filter
        diseqAnd varDiseq f varLHS= And (varLHS :≠ varDiseq) (f varDiseq)
        lineAnd f g varLHS = And (f varLHS) (g varLHS)
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptDomain :: Parser (BConcept Domain)
  pConceptDomain =     pIntersection
                   <|> pUnion
      where 
        pIntersection, pUnion, pElemDomain :: Parser (BConcept Domain)
        pElemFilter :: Parser (BConcept Filter)
        pIntersection =   isectD
                          <$> pElemDomain
                          <*  pK "and"
                          <*> (isectF <$ pK "and") `pChainr` pElemFilter
        pUnion      =     (union <$ pK "or") `pChainr` pElemDomain
        pElemDomain =     pDomainId
                      <|> pParens pConceptDomain -- Recursion
        pElemFilter =     rebox <$> pDomainId
                      <|> pFilterId
                      <|> pParens pConceptFilter -- Only dep. with pConceptFilter
                      <|> compl <$ pK "not" <*> pElemFilter -- Recursion
        isectF (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x :⊓ y)
        isectD (MkBConceptDomain x) (MkBConceptFilter y) = MkBConceptDomain (x :⊓ y)
        union  (MkBConceptDomain x) (MkBConceptDomain y) = MkBConceptDomain (x :⊔ y)
        compl  (MkBConceptFilter x)                      = MkBConceptFilter (C x)
        rebox  (MkBConceptDomain x)                      = MkBConceptFilter x
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptFilter :: Parser (BConcept Filter)
  pConceptFilter =     pIntersection
                   <|> pUnion
      where 
        pIntersection, pUnion, pElem :: Parser (BConcept Filter)
        pIntersection = isect
                        <$> pElem
                        <*  pK "and"
                        <*> (isect <$ pK "and") `pChainr` pElem
        pUnion =        (union <$ pK "or") `pChainr` pElem
        pElem  =        rebox <$> pDomainId
                    <|> pFilterId
                    <|> pParens pConceptFilter          -- Recursion
                    <|> compl <$ pK "not" <*> pElem     -- Recursion
        isect (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x :⊓ y)
        union (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x :⊔ y)
        compl (MkBConceptFilter x)                      = MkBConceptFilter (C x)
        rebox (MkBConceptDomain x)                      = MkBConceptFilter x
#+end_src


* Parsers for terminal symbols, lexical analysis

All parsers for terminal symbols are responsible of munching
whitespace after them and take care of possible comments, usually by
means of the =lexeme= parser transformer.

#+begin_src haskell
  
  -- | Sets indentation at current column and parses @p@ with that
  -- indentation: all tokens in @p@ must start at a grater column than
  -- that indentation, except those marked with @atIndent@, that must
  -- start at this very same column. Token parsers fail if the wrong
  -- indentation is found.
  indented :: ParserTrafo a a
  indented p =
      pSwitch (\old ->
                   (         old {pos = setIndentAtCurrentCol (pos old)}
                   , \new -> new {pos = copyIndent (pos old) (pos new) }
                   )
               ) p
          where
            setIndentAtCurrentCol (LineColPosIndent l c p _) =
                LineColPosIndent l c p c
            copyIndent (LineColPosIndent _ _ _ i) (LineColPosIndent l c p _) =
                LineColPosIndent l c p i
  
  -- | If an indentation has been previously fixed with @indented@,
  -- @atIndent p@ accepts @p@ only if it starts at the very same column
  -- fixed by that indentation.
  atIndent :: ParserTrafo a a
  atIndent p =
      pCheckIndent (==)
      *> pSwitch (\old ->
                      (         old {pos = resetIndent (pos old)         }
                      , \new -> new {pos = copyIndent (pos old) (pos new)}
                      )
                 ) p
          where
            resetIndent (LineColPosIndent l c p _) = LineColPosIndent l c p (-1)
            copyIndent (LineColPosIndent _ _ _ i) (LineColPosIndent l c p _) =
                LineColPosIndent l c p i
  
  pVar :: Parser Var
  pVar = pUpperId
  
  pRoleName :: Parser RoleName
  pRoleName = pLowerId
  
  -- | At the moment we only support sort names beginning with an upper
  -- case letter (no "_", etc.)
  pDomainId :: Parser (BConcept Domain)
  pDomainId = MkBConceptDomain . D <$> pUpperId
  
  -- | At the moment we only support filter names beginning with a lower
  -- case letter (no "_", etc.)
  pFilterId :: Parser (BConcept Filter)
  pFilterId = MkBConceptFilter . F <$> pLowerId
  
  -- | Parser for keywords.
  pK :: Text -> Parser Text
  pK keyword =
      lexeme $ pToken keyword <* pMaybe (pMunch idChar <* empty)
  
  -- | Parser for operators.
  pO :: Text -> Parser Text
  pO operator =
      lexeme $ pToken operator
  
  pParens :: ParserTrafo a a
  pParens p = lexeme (pSym '(') *> p <* lexeme (pSym ')')
#+end_src

The following functions replace an analogous function in
Text.ParserCombinators.UU.[BasicInstances|Utils]. The original version
works with String, whereas this version has Data.Text in the
signature, but uses String internally. My understanding of
Text.ParserCombinators.UU is that it doesn't support Data.Text at the
low level, as functions like =pToken= and =pMunch= return a list of
something.

#+begin_src haskell
  -- | Replaces @lexeme@ in @Text.ParserCombinators.UU.Utils@. This
  -- version is intended to skip comments, in addition to trailing
  -- whitespace, and supports layout-based (i.e. indentation-based)
  -- parsing.
  lexeme :: ParserTrafo a a
  lexeme p = pCheckIndent (>) *> p <* (pMany pComment <<|> pure [()])
      where pComment =      const () <$ pAnySym (" \r\n\t") <*> pSpaces
                       <<|> pMultilineComment
                       <|>  pOneLineComment
  
  pTokenCost :: Text -> Int -> Parser Text
  pTokenCost tk cost = fromList <$> UU.pTokenCost (toList tk) cost
  
  pToken :: Text -> Parser Text
  pToken tk = pTokenCost tk 5
    
  pMunch :: (Char -> Bool) -> Parser Text
  pMunch pred = fromList <$> UU.pMunch pred
#+end_src

Auxiliary functions.

#+begin_src haskell
  pCheckIndent :: (Int -> Int -> Bool) -> Parser ()
  pCheckIndent comp = pSymExt splitState (Zero Infinite) Nothing
      where
        splitState :: forall st r . (LL.ListLike st Char) =>
                      (() -> (Str Char st LineColPosIndent) -> Steps r)
                          -> (Str Char st LineColPosIndent) -> Steps r
        splitState k inp@(Str tts msgs pos@(LineColPosIndent l c p i) delOk) =
            if c `comp` i
            then k () inp
            else let msg = "or deleted whitespace"
                     ins exp =
                         (3, k () (Str tts (msgs ++ [Inserted msg pos exp]) pos delOk))
                 in Fail ["Different indentation"] [ins]
  
  pLowerId :: Parser Text
  pLowerId = lexeme $ cons <$> pLower <*> pMunch idChar
  
  pUpperId :: Parser Text
  pUpperId = lexeme $ cons <$> pUpper <*> pMunch idChar
  
  idChar :: Char -> Bool
  idChar c = or $ map ($ c) [isAsciiLower, isAsciiUpper, isDigit, (=='\''), (=='_')]
  
  pOneLineComment :: Parser ()
  pOneLineComment = const () <$> pToken "//" <* pMunch (/= '\n')
  
  -- | Any printable symbol is allowed in a multiline comment. No nested
  -- multiline comments are allowed. New lines inside a multiline
  -- comment are not taken into account.
  pMultilineComment :: Parser ()
  pMultilineComment =
      const () <$> pToken "/*" <* pMunch (/= '*') <* pSym '*' <* pAux
      where pAux =      pSym '/'
                   <<|> pMunch (/= '*') *> pSym '*' <* pAux
#+end_src


* File handling

#+begin_src haskell
  translateFile :: String -> IO ()
  translateFile crispFileName = do
    let baseFileNameM
            = (stripPrefix (reverse ".crisp") $ reverse crispFileName) >>= return . reverse
    case baseFileNameM of
      Nothing -> return ()
      Just baseFileName ->
          do let prologFileName = baseFileName ++ ".pl"
             concreteSyntax <- readFile crispFileName
             abstractSyntax <- run pModule concreteSyntax
             prologCode <-
                 do ep <- P.emptyEP
                    ep <- P.addEPCs (map relationToProlog abstractSyntax) ep
                    return $ P.transLloydTopor ep
             writeFile prologFileName $ P.show prologCode
#+end_src

#+begin_src haskell
  run :: Parser t -> Text -> IO t
  run p inp =
      do let r@(a, errors) =
                 parse ((,) <$ pSpaces <*> p <*> pEnd) (createStrIndent inp)
             show_errors :: (Show a) => [a] -> IO ()
             show_errors = sequence_ . (map (putStrLn . show))
         -- putStrLn ("--  Result: " ++ show a)
         if null errors then return ()
         else do putStr ("--  Correcting steps: \n")
                 show_errors errors
         return a
#+end_src


* Tests

Load Haskell module, first time.

#+begin_src haskell :var pwd=(pwd) :tangle no :results output silent
  let cd_pwd = return $ ":cd " ++ drop 10 pwd :: IO String
  :cmd cd_pwd
  :cd ..
  :l Crisp.ConcreteSyntax
#+end_src

#+begin_src haskell :tangle no :results output silent
  :set -XOverloadedStrings
  :set -XNoMonomorphismRestriction
  let a = "FunctionDecl   or CXXMethodDecl"
  let b = "  CXXMethodDecl and virtual and abstract"
  let c = "  virtual and CXXMethodDecl and abstract"
  let d = "CXXRecordDecl"
  let e = " (CXXRecordDecl)"
  let f = " (CXXMethodDecl and virtual) or CXXConstructorDecl   "
  let g = "CXXMethodDecl and FunctionDecl or  CXXConstructorDecl"
  let h = "CXXMethodDecl or  FunctionDecl and CXXConstructorDecl"
  putStrLn "OK"
  mapM_ (run pConceptDomain) [a, b,    d, e, f]
  mapM_ (run pConceptFilter) [a, b, c, d, e, f]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [a, b,    d, e, f]
  putStrLn "KO"
  mapM_ (run pConceptDomain) [c, g, h]
  mapM_ (run pConceptFilter) [   g, h]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [c, g, h]
  putStrLn "END"
#+end_src
