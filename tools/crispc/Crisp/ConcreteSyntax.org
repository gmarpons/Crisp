# ConcreteSyntax.org -----------------------------------------------------------

# Copyright (C) 2011, 2012 Guillem Marpons <gmarpons@babel.ls.fi.upm.es>
#
# This file is part of Crisp.
#
# Crisp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Crisp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Crisp.  If not, see <http://www.gnu.org/licenses/>.

#+PROPERTY: tangle yes
#+PROPERTY: exports code

This is an Org-mode file with Haskell code blocks that can be tangled
(in a literate programming sense) within Emacs with C-c C-v t.

Code blocks in [[*Tests][Tests]] can be loaded and executed in a GHCi session
with C-C C-c.

* Module declaration

#+begin_src haskell
  {-# LANGUAGE
    GADTs,
    FlexibleContexts,
    FlexibleInstances,
    MultiParamTypeClasses,
    NoMonomorphismRestriction,
    Rank2Types,
    TypeSynonymInstances
    #-}
  
  module Crisp.ConcreteSyntax where
  
  import Crisp.AbstractSyntax
  import Data.Char
      (isAsciiUpper, isAsciiLower, isDigit)
  import Data.Maybe
      (isJust)
  import Text.ParserCombinators.UU.BasicInstances
      (createStr, LineColPos(LineColPos), pMunch, pSym, pToken, Parser, ParserTrafo)
  import Text.ParserCombinators.UU.Core
      ((*>), (<$), (<$>), (<*), (<**>), (<*>), (<<|>), (<?>), (<|>),
       opt, parse, pEnd)
  import Text.ParserCombinators.UU.Derived
      (pChainr, pFail, pMaybe, pSome)
  import Text.ParserCombinators.UU.Utils
      (pLower, pUpper)
#+end_src


* Parsers for non-terminal symbols
  
#+begin_src haskell
  pFormulaDomain :: Parser (Formula Domain)
  pFormulaDomain = ConceptAssert <$> pVar <* pK "is" <*> pConceptDomain
  
  -- | Lines are conjunctively chained (association to the right). There
  -- are two kinds of line: assertion lines, and lines for
  -- (dis-)equality relations. Both kinds of line begin with a
  -- variable. (Dis-)equality relations cannot appear in an assertion
  -- line.
  pFormulaFilter :: Parser (Formula Filter)
  pFormulaFilter = (And <$ pN) `pChainr` pLine
      where 
        pLine :: Parser (Formula Filter)
        pRHS  :: Parser (Var -> Formula Filter)
        pLine = pVar <**> pRHS
        pRHS  =     pAsserts
                <|> pEqRelations
  
  -- | This parser receives a variable found at the beginning of a line
  -- (LHS variable) and parses a number of conjunctively chained
  -- (right-associative) assertions about this variable.
  pAsserts :: Parser (Var -> Formula Filter)
  pAsserts = (lineAnd <$ pO ",") `pChainr` pAssertElem
      where
        pAssertElem ::Parser (Var -> Formula Filter)
        pRoleId     :: Parser RoleId
        pAssertElem =     flip    ConceptAssert <$  pK "is" <*> pConceptFilter
                      <|> reorder RoleAssert    <$> pRoleId             <*> pVar
                      <|> reorder RoleAssertT   <$> pRoleId <*  pO "+"  <*> pVar
                      <|> reorder RoleAssertRT  <$> pRoleId <*  pO "*"  <*> pVar
        pRoleId     = flip (,) <$> isJust <$> pMaybe (pK "has") <*> pRoleName
        lineAnd  :: (Var -> Formula Filter) -> (Var -> Formula Filter)
                 ->  Var -> Formula Filter
        reorder :: (a -> b -> c -> d) -> b -> c-> a -> d
        lineAnd f g varLHS = And (f varLHS) (g varLHS)
        reorder f b c a = f a b c
  
  -- | This parser receives a variable found at the beginning of a line
  -- (LHS variable) and parses a number of (dis-)equalities with that
  -- variable. Any number of chained equalities is allowed (e.g. of
  -- three chained equalities: X = Y = Z), but a maximum of one explicit
  -- disequality can appear in a line. All the variables to the left
  -- (resp. right) of the disequality symbol are unified. All the
  -- variables to the left of the disequality symbol are declared
  -- different from all the variables to the right.
  pEqRelations :: Parser (Var -> Formula Filter)
  pEqRelations =     lineAnd <$> pEqualities <*> (pDiseqAndEqs `opt` const Top)
                 <|> pDiseqAndEqs
      where
        pDiseqAndEqs, pEqualities, pEquality :: Parser (Var -> Formula Filter)
        pDiseqAndEqs = diseqAnd <$ pO "/=" <*> pVar <*> (pEqualities `opt` const Top)
        pEqualities  = pO "=" *> (lineAnd <$ pO "=") `pChainr` pEquality
        pEquality    = flip (:=) <$> pVar
        diseqAnd :: Var -> (Var -> Formula Filter) -> Var -> Formula Filter
        lineAnd  :: (Var -> Formula Filter) -> (Var -> Formula Filter)
                 ->  Var -> Formula Filter
        diseqAnd varDiseq f varLHS= And (varLHS :≠ varDiseq) (f varDiseq)
        lineAnd f g varLHS = And (f varLHS) (g varLHS)
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptDomain :: Parser (BConcept Domain)
  pConceptDomain =     pIntersection
                   <|> pUnion
      where 
        pIntersection, pUnion, pElemDomain :: Parser (BConcept Domain)
        pElemFilter :: Parser (BConcept Filter)
        pIntersection =   isectD
                          <$> pElemDomain
                          <*  pK "and"
                          <*> (isectF <$ pK "and") `pChainr` pElemFilter
        pUnion      =     (union <$ pK "or") `pChainr` pElemDomain
        pElemDomain =     pDomainId
                      <|> pParens pConceptDomain -- Recursion
        pElemFilter =     rebox <$> pDomainId
                      <|> pFilterId
                      <|> pParens pConceptFilter -- Only dep. with pConceptFilter
                      <|> compl <$ pK "not" <*> pElemFilter -- Recursion
        isectF (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x :⊓ y)
        isectD (MkBConceptDomain x) (MkBConceptFilter y) = MkBConceptDomain (x :⊓ y)
        union  (MkBConceptDomain x) (MkBConceptDomain y) = MkBConceptDomain (x :⊔ y)
        compl  (MkBConceptFilter x)                      = MkBConceptFilter (C x)
        rebox  (MkBConceptDomain x)                      = MkBConceptFilter x
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptFilter :: Parser (BConcept Filter)
  pConceptFilter =     pIntersection
                   <|> pUnion
      where 
        pIntersection, pUnion, pElem :: Parser (BConcept Filter)
        pIntersection = isect
                        <$> pElem
                        <*  pK "and"
                        <*> (isect <$ pK "and") `pChainr` pElem
        pUnion =        (union <$ pK "or") `pChainr` pElem
        pElem  =        rebox <$> pDomainId
                    <|> pFilterId
                    <|> pParens pConceptFilter          -- Recursion
                    <|> compl <$ pK "not" <*> pElem     -- Recursion
        isect (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x:⊓y)
        union (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x:⊔y)
        compl (MkBConceptFilter x)                      = MkBConceptFilter (C x)
        rebox (MkBConceptDomain x)                      = MkBConceptFilter x
#+end_src


* Parsers for terminal symbols, lexical analysis

All parsers for terminal symbols are responsible of munching
whitespace after them and take care of possible comments.

#+begin_src haskell
  pVar :: Parser Var
  pVar = pUpperId

  pRoleName :: Parser RoleName
  pRoleName = pLowerId

  -- | At the moment we only support sort names beginning with an upper
  -- case letter (no "_", etc.)
  pDomainId :: Parser (BConcept Domain)
  pDomainId = MkBConceptDomain . D <$> pUpperId
  
  -- | At the moment we only support filter names beginning with a lower
  -- case letter (no "_", etc.)
  pFilterId :: Parser (BConcept Filter)
  pFilterId = MkBConceptFilter . F <$> pLowerId
  
  -- | Parser for keywords.
  pK :: String -> Parser String
  pK keyword =
      pTerminal $ pToken keyword <* pMaybe (pMunch idChar <* pFail)

  -- | Parser for operators.
  pO :: String -> Parser String
  pO operator =
      pTerminal $ pToken operator

  -- | Parser for new lines.
  pN :: Parser [Char]
  pN = pSome $ pTerminal (pSym '\n')
  
  pParens :: ParserTrafo a a
  pParens p = pTerminal (pSym '(') *> p <* pTerminal (pSym ')')
#+end_src

Auxiliary functions.

#+begin_src haskell
  pTerminal :: ParserTrafo a a
  pTerminal p = p <* pSpaces <* (pComment `opt` ())
      where pComment =     pOneLineComment
                       <|> pMultilineComment
  
  pLowerId :: Parser String
  pLowerId = pTerminal $ (:) <$> pLower <*> pMunch idChar
  
  pUpperId :: Parser String
  pUpperId = pTerminal $ (:) <$> pUpper <*> pMunch idChar
  
  idChar :: Char -> Bool
  idChar c = or $ map ($ c) [isAsciiLower, isAsciiUpper, isDigit, (=='\''), (=='_')]
  
  -- | This parser hides the one in UU.Utils, because in our lexer
  -- newlines are semantically significant and we don't allow tabs
  -- outside comments.
  pSpaces :: Parser ()
  pSpaces = const () <$> pMunch (`elem` " \r") <?> "Whitespace"
  
  pOneLineComment :: Parser ()
  pOneLineComment = const () <$> pToken "--" <* pMunch (/= '\n')
  
  -- | Any printable symbol is allowed in a multiline comment. No nested
  -- multiline comments are allowed. New lines inside a multiline
  -- comment are not taken into account.
  pMultilineComment :: Parser ()
  pMultilineComment =
      const () <$> pToken "{-" <* pMunch (/= '-') <* pSym '-' <* pAux <* pSpaces
      where pAux =      pSym '}'
                   <<|> pMunch (/= '-') *> pSym '-' <* pAux
#+end_src


* File handling

#+begin_src haskell
  -- translateFile :: String -> IO ()
  -- translateFile fileName = do
  --   result <- parseFromFileEx rulesFile fileName
  --   case result of
  --     Failure diags -> unless (Seq.null diags) $ displayLn diags
  --     Success diags translation -> do
  --                            unless (Seq.null diags) $ displayLn diags
  --                            print translation
#+end_src


* Tests

Load Haskell module, first time.

#+begin_src haskell :var pwd=(pwd) :tangle no :results output
  let cd_pwd = return $ ":cd " ++ drop 10 pwd :: IO String
  :cmd cd_pwd
  :cd ..
  :l Crisp.ConcreteSyntax
#+end_src

#+begin_src haskell
  run :: Show t => Parser t -> String -> IO ()
  run p inp =
      do let r@(a, errors) = parse 
                             ((,) <$ pSpaces <*> p <*> pEnd) 
                             (createStr (LineColPos 0 0 0) inp)
         putStrLn ("--  Result: " ++ show a)
         if null errors then return ()
         else do putStr ("--  Correcting steps: \n")
                 show_errors errors
         putStrLn "-- "
      where show_errors :: (Show a) => [a] -> IO ()
            show_errors = sequence_ . (map (putStrLn . show))
  
  pa :: Parser String 
  pa = (:[]) <$> pSym 'a'
#+end_src

#+begin_src haskell :tangle no :results output
  let a = "FunctionDecl   or CXXMethodDecl"
  let b = "  CXXMethodDecl and virtual and abstract"
  let c = "  virtual and CXXMethodDecl and abstract"
  let d = "CXXRecordDecl"
  let e = " (CXXRecordDecl)"
  let f = " (CXXMethodDecl and virtual) or CXXConstructorDecl   "
  let g = "CXXMethodDecl and FunctionDecl or  CXXConstructorDecl"
  let h = "CXXMethodDecl or  FunctionDecl and CXXConstructorDecl"
  putStrLn "OK"
  mapM_ (run pConceptDomain) [a, b,    d, e, f]
  mapM_ (run pConceptFilter) [a, b, c, d, e, f]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [a, b,    d, e, f]
  putStrLn "KO"
  mapM_ (run pConceptDomain) [c, g, h]
  mapM_ (run pConceptFilter) [   g, h]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [c, g, h]
  putStrLn "END"
#+end_src
