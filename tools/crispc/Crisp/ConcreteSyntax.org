# ConcreteSyntax.org -----------------------------------------------------------

# Copyright (C) 2011, 2012 Guillem Marpons <gmarpons@babel.ls.fi.upm.es>
#
# This file is part of Crisp.
#
# Crisp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Crisp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Crisp.  If not, see <http://www.gnu.org/licenses/>.

#+PROPERTY: tangle yes
#+PROPERTY: exports code

This is an Org-mode file with Haskell code blocks that can be tangled
(in a literate programming sense) within Emacs with C-c C-v t.

Code blocks in [[*Tests][Tests]] can be loaded and executed in a GHCi session
with C-c C-c.

* Module declaration

#+begin_src haskell
  {-# LANGUAGE
    GADTs,
    FlexibleContexts,
    FlexibleInstances,
    MultiParamTypeClasses,
    NoImplicitPrelude,
    NoMonomorphismRestriction,
    OverloadedStrings,
    ParallelListComp,
    Rank2Types,
    ScopedTypeVariables,
    TypeOperators
    #-}
  
  module Crisp.ConcreteSyntax where
  
  import ClassyPrelude
  import ClassyPrelude.Classes
      (CanDeleteVal(deleteVal), CanReadFile, CanReverse, CanWriteFileFunc(writeFileFunc))
  import Crisp.AbstractSyntax
  import Data.Char
      (isAsciiUpper, isAsciiLower, isDigit)
  import Data.Foldable
      (or, sequence_)
  import Data.List
      (transpose)
  import qualified Data.List
      (delete, nub)
  import qualified Data.List as ListPartialFunctions
      (head, tail)
  import Data.List.NonEmpty
      (NonEmpty((:|)),
       (<|),
       head, tail)                -- These are total functions
  import qualified Data.List.NonEmpty
      (reverse)
  import qualified Data.ListLike.Base as LL
      (ListLike(fromList, head, null, singleton, tail, toList))
  import qualified Data.ListLike.FoldableLL as LL
      (FoldableLL(foldl, foldr))
  import Data.String
      (String)
  import qualified Data.Text as TextPartialFunctions
      (head, tail)
  import Data.Text
      (cons)
  import qualified Data.Text
      (foldl, foldr)
  import Data.Text.IO
      (putStr, putStrLn)
  import qualified Data.Text.IO
      (readFile, writeFile)
  import Filesystem.Path
      (FilePath, hasExtension, replaceExtension)
  import qualified Filesystem.Path.CurrentOS as OS
      (decodeString, encodeString)
  import qualified Text.ParserCombinators.UU.BasicInstances as UU
      (pMunch, pTokenCost)
  import Text.ParserCombinators.UU.BasicInstances
      (createStr, Error(Inserted), Insertion(Insertion), pos, pSatisfy,
       pSym, Str(Str))
  import Text.ParserCombinators.UU.Core
      ((*>), (<$), (<$>), (<*), (<**>), (<*>), (<<|>), (<?>), (<|>),
       IsLocationUpdatedBy(..), IsParser, Nat(..), P, Steps(Fail),
       addLength, opt, parse, pEnd, pSymExt, pSwitch)
  import qualified Text.ParserCombinators.UU.Core
      (empty)
  import Text.ParserCombinators.UU.Derived
      ((<$$>),
       pAny, pChainr, pEither, pFoldr, pMany, pMaybe)
  import qualified Text.ParserCombinators.UU.MergeAndPermute as UU
      (Gram)
  import Text.ParserCombinators.UU.MergeAndPermute
      ((<||>),
       mkGram, mkParserM)
  -- In contrast with other UU.Utils functions, none of the following
  -- imported functions calls lexeme.
  import Text.ParserCombinators.UU.Utils
      (pAnySym, pLower, pSpaces, pUpper)
  import qualified Crisp.PrologSyntax as P
#+end_src


* Class instances

#+begin_src haskell
  instance CanDeleteVal [Text] Text where
      deleteVal = Data.List.delete
  
  instance CanReverse (NonEmpty a) where
      reverse = Data.List.NonEmpty.reverse
  
  instance CanReadFile (IO Text) where
      readFile = Data.Text.IO.readFile . OS.encodeString
  
  instance CanWriteFileFunc Text where
      writeFileFunc p c = liftIO $ Data.Text.IO.writeFile (OS.encodeString p) c
#+end_src


* Location datatype

We replace type synonims =Parser= and =ParserTrafo= from
=Text.ParserCombinators.UU.BasicInstances= to more specific versions
that use a special location datatype, =LineColPosIndent=, designed to
allow parsing based on layout (indentation).

#+begin_src haskell
  data LineColPosIndent = LineColPosIndent !Int !Int !Int !Int deriving Show
  
  instance LineColPosIndent `IsLocationUpdatedBy` Char where
     advance (LineColPosIndent line col pos indent) c
         | c == '\n' = LineColPosIndent (line + 1) 0         (pos + 1) indent
         | c == '\t' = LineColPosIndent line       tabCol    (pos + 1) indent
         | otherwise = LineColPosIndent line       (col + 1) (pos + 1) indent
         where tabCol = col + 8 - (col - 1) `mod` 8
  
  instance LL.FoldableLL Text Char where
      foldl = Data.Text.foldl
      foldr = Data.Text.foldr
  
  instance LL.ListLike Text Char where
      singleton = singleton
      head = TextPartialFunctions.head
      tail = TextPartialFunctions.tail
      null = null
  
  createStrIndent :: LL.ListLike s Char => s -> Str Char s LineColPosIndent
  createStrIndent inp = createStr (LineColPosIndent 0 0 0 (-1)) inp
  
  type Parser a = LL.ListLike s Char => P (Str Char s LineColPosIndent) a
  
  type ParserTrafo a b = Parser a -> Parser b
  
  type Gram a = LL.ListLike s Char => UU.Gram (P (Str Char s LineColPosIndent)) a
  
  instance LL.ListLike s Char => Monoid (P (Str Char s LineColPosIndent) a) where
      mempty  = Text.ParserCombinators.UU.Core.empty
      mappend = (<|>)
#+end_src


* Parsers for non-terminal symbols

#+begin_src haskell
  -- | nub ('essence') function for NonEmpty lists. Removes repeated
  -- elements, keeping the first occurrence of every element (i.e.,
  -- preserves order). Only applicable to finite non-empty lists.
  nub :: (Eq a) => NonEmpty a -> NonEmpty a
  nub (x :| xs) = reverse $ nub' xs (x :| [])
      where nub' []       ls                                   = ls
            nub' (x : xs) ls@(y :| ys) | x == y || x `elem` ys = nub' xs ls
                                       | otherwise             = nub' xs (x <| ls)
#+end_src

  
#+begin_src haskell
  pModule :: Parser Module
  pModule = pMany pRelation
  
  pRelation :: Parser (Relation)
  pRelation = indented pRelation'
      where
        pRelation', pPred, pPred', pConcept, pRole, pRule :: Parser Relation
        pRelation' =     pPred
                     <|> pRule
        pPred    = atIndent (pK "pred") *> pPred'
        pPred'   =     pConcept
                   <|> pRole
        pConcept = uncurry ConceptDef <$> pConceptIdAndVars <*> pMeet
        pRole    = uncurry RoleDef    <$> pRoleIdAndVars    <*> pMeet
        pRule    = atIndent (pK "rule") *> pRule'
        pRule'   = mkRule <$> pRuleId <*> pMsgsAndVars <*> pMeet
        pRuleId  = (,) <$> pRuleSetId <*> pRuleName
        pMeet :: Parser (Formula Filter)
        pMeet = atIndent (pK "meet") *> pFormulaFilter
        mkRule :: RuleId -> (Msgs, NonEmpty (Formula Domain)) -> Formula Filter -> Relation
        mkRule id (msgs, domains) filter = Rule id msgs domains filter
  
  -- The following parser uses monadic bind, and consequently needs to
  -- declare its minimal (token = character) length.
  -- Read http://clang.llvm.org/docs/InternalsManual.html#producing-the-diagnostic.
  pMsgsAndVars :: Parser (Msgs, NonEmpty (Formula Domain))
  pMsgsAndVars = addLength 34 $ do
    atIndent (pK "warn")
    (formatStr_, allVarsWithReps) <- pFormatStr
    let allVars_ = nub allVarsWithReps           -- No repeated elems, but preserve order.
    pK "show"
    mainVar_     <- pAny pCheck (toList allVars_)
    displayMode_ <- pVarDisplayMode
    let message = Message (mkFormatStr formatStr_ allVarsWithReps) mainVar_ displayMode_ allVars_
    ds <- pSomeDomains allVars_
    return (Msgs message, ds)
        where
          pVarDisplayMode :: Parser VarDisplayMode
          pVarDisplayMode =     Location <$ pK "location"
                            <|> Range    <$ pK "range"
          pSomeDomains :: NonEmpty Var -> Parser (NonEmpty (Formula Domain))
          pSomeDomains vars = atIndent (pK "vars") *> (indented $ mkParserM (gSomeDomains vars))
          gSomeDomains :: NonEmpty Var -> Gram (NonEmpty (Formula Domain))
          gSomeDomains (v :| vs)
              = liftM reverse $ fold combineVarAsserts ((:| []) <$> gDomain v) (map gDomain vs)
          pCheck :: Var -> Parser Var
          pCheck = pK
          mkFormatStr :: NonEmpty Text -> NonEmpty Var -> Text
          mkFormatStr ts vs = (concat . concat) $ transpose [toList ts, (toNumbers . toList) vs]
          toNumbers vars = map (maybe "Error" show . flip lookup (varsAL (Data.List.nub vars))) vars
          varsAL vars = [(var, num) | var <- vars | num <- [0..]]
          combineVarAsserts gds gd = (<|) <$$> gds <||> gd
  
  pFormatStr :: Parser (NonEmpty Text, NonEmpty Var)
  pFormatStr = pSym '\"' *> pFormatStr' <* pK "\""
      where
        pFormatStr'                                :: Parser (NonEmpty Text, NonEmpty Var)
        pManyEsc_Text_Esc, pText_Esc, pEsc, pNoEsc :: Parser Text
        pSpecialCpp_Text, pSpecialCpp              :: Parser Text
        pEsc_Var_Text                              :: Parser (Either ((Text, Text), Var) Text)
        pEitherVarEsc                              :: Parser (Either Var Text)
        pFormatVar                                 :: Parser Var
        pFormatStr' = mkFormatStr <$> pText_Esc <*> pManyEsc_Text_Esc <*> pFormatVar <*> pManyVars
        pManyEsc_Text_Esc = concat <$> pMany ((++) <$> pEsc <*> pText_Esc)
        pText_Esc = (++) <$> pNoEsc <*> pEsc
        pEsc_Var_Text = mkEsc_Var_Text <$> pEsc <*> pEitherVarEsc <*> pNoEsc
        pEitherVarEsc = pEither pFormatVar pEsc
        pFormatVar = cons <$> pUpper <*> pMunch idChar -- No lexeme
        pEsc = singleton <$> pSym '%'
        pNoEsc = (++) <$> pMunch noEscChar <*> (concat <$> pMany pSpecialCpp_Text)
        pSpecialCpp_Text = (++) <$> pSpecialCpp <*> pMunch noEscChar
        -- <|> TODO: other C++ special chars.
        pSpecialCpp = cons <$> pSym '\\' <*> (singleton <$> pAnySym "\"\\")
        mkFormatStr :: Text -> Text -> Var -> NonEmpty (Either Text Var)
                    -> (NonEmpty Text, NonEmpty Var)
        mkFormatStr x y v (Left z :| es) = ( (x ++ y) <| z :| fst (partitionEithers es)
                                           , v             :| snd (partitionEithers es))
        -- mkFormatStr x y v (Right _ :| _) = Impossible case!
        pManyVars :: Parser (NonEmpty (Either Text Var))
        pManyVars = mkManyVars <$> pNoEsc <*> pMany pEsc_Var_Text
        mkManyVars x l = reverse $ fold combineEithers (Left x :| []) l
        combineEithers (Left  t :| es) (Left ((x, y), v)) = Left y <| Right v <| Left (t ++ x) :| es
        combineEithers (Left  t :| es) (Right x)          = Left (t ++ x) :| es
        -- combineEithers (Right v :| es) _ = Impossible case!
        mkEsc_Var_Text :: Text -> Either Var Text -> Text -> Either ((Text, Text), Var) Text
        mkEsc_Var_Text x (Left  v) y = Left ((x, y), v)
        mkEsc_Var_Text x (Right t) y = Right (x ++ t ++ y)
        noEscChar c = c /= '\"' && c /= '%' && c /= '\\'
  
  -- The following parser uses monadic bind, and consequently needs to
  -- declare its minimal (token = character) length.
  pConceptIdAndVars :: Parser (ConceptId, Formula Domain)
  pConceptIdAndVars = addLength 18 $ do
    v  <- pVar
    id <- pConceptId
    d  <- pOneDomain v
    return (id, d)
        where
          pConceptId              :: Parser ConceptId
          pOneDomain, pOneDomain' :: Var -> Parser (Formula Domain)
          pConceptId              = pK "is" *> pLowerId
          pOneDomain  var         = atIndent (pK "vars") *> pOneDomain' var
          pOneDomain' var         = indented $ mkParserM (gDomain var)
  
  -- The following parser uses monadic bind, and consequently needs to
  -- declare its minimal (token = character) length.
  pRoleIdAndVars    :: Parser (RoleId, (Formula Domain, Formula Domain))
  pRoleIdAndVars = addLength 26 $ do
    v1 <- pVar
    id <- pRoleId
    v  <- pVar
    v2 <- if v == v1 then do
                       -- If repeated var name, we append "@" to
                       -- it, a character not allowed in ordinary vars.
                       let msg = "different variable name"
                       c <- pSatisfy (const False) (Insertion msg '@' 0)
                       return (v ++ pack [c])
          else return v
    (d1, d2) <- pTwoDomains v1 v2
    return (id, (d1, d2))
        where
          pRoleId :: Parser RoleId
          pTwoDomains, pTwoDomains' :: Var -> Var -> Parser (Formula Domain, Formula Domain)
          pRoleId    = (,) <$$> (True  <$ pK "has" `opt` False) <*> pLowerId
          pTwoDomains  v1 v2 = atIndent (pK "vars") *> pTwoDomains' v1 v2
          pTwoDomains' v1 v2 = indented $ mkParserM $ (,) <$> gDomain v1 <||> gDomain v2
  
  gDomain :: Var -> Gram (Formula Domain)
  gDomain var
      = mkGram $ ConceptAssert <$> atIndent (pCheck var) <* pK "is" <*> pConceptDomain
      where
        pCheck = pK
  
  pFormulaDomain :: Parser (Formula Domain)
  pFormulaDomain = ConceptAssert <$> pVar <* pK "is" <*> pConceptDomain
  
  -- | Lines are conjunctively chained (association to the right). There
  -- are two kinds of line: assertion lines, and lines for
  -- (dis-)equality relations. Both kinds of line begin with a
  -- variable. (Dis-)equality relations cannot appear in an assertion
  -- line.
  pFormulaFilter :: Parser (Formula Filter)
  pFormulaFilter = indented $ pFoldr (And, Top) pLine
      where 
        pLine :: Parser (Formula Filter)
        pRHS  :: Parser (Var -> Formula Filter)
        pLine =     atIndent pVar <**> pRHS     -- pVar begins with upper case
                <|> pDisjunction                -- pDisjunction begins with "e"
        pRHS  =     pAsserts
                <|> pEqRelations
  
  pDisjunction :: Parser (Formula Filter)
  pDisjunction = Or <$> pLeftDisj <*> pRightDisj
      where
        pLeftDisj  :: Parser (Formula Filter)
        pRightDisj :: Parser (Formula Filter)
        pOtherDisj :: Parser (Formula Filter)
        pLeftDisj  = atIndent (pK "either") *> pFormulaFilter             -- Mut. rec.
        pRightDisj = atIndent (pK "or") *> pOtherDisj
        pOtherDisj = (Or <$ atIndent (pK "or")) `pChainr` pFormulaFilter  -- Mut. rec.
  
  -- | This parser receives a variable found at the beginning of a line
  -- (LHS variable) and parses a number of conjunctively chained
  -- (right-associative) assertions about this variable.
  pAsserts :: Parser (Var -> Formula Filter)
  pAsserts = (lineAnd <$ pO ",") `pChainr` pAssertElem
      where
        pAssertElem :: Parser (Var -> Formula Filter)
        pRoleId     :: Parser RoleId
        pAssertElem =      flip    ConceptAssert <$  pK "is" <*> pConceptFilter
                      <<|> reorder RoleAssert    <$> pRoleId             <*> pVar
                      <|>  reorder RoleAssertT   <$> pRoleId <*  pO "+"  <*> pVar
                      <|>  reorder RoleAssertRT  <$> pRoleId <*  pO "*"  <*> pVar
        pRoleId     = flip (,) <$> isJust <$> pMaybe (pK "has") <*> pRoleName
        lineAnd  :: (Var -> Formula Filter) -> (Var -> Formula Filter)
                 ->  Var -> Formula Filter
        reorder :: (a -> b -> c -> d) -> b -> c-> a -> d
        lineAnd f g varLHS = And (f varLHS) (g varLHS)
        reorder f b c a = f a b c
  
  -- | This parser receives a variable found at the beginning of a line
  -- (LHS variable) and parses a number of (dis-)equalities with that
  -- variable. Any number of chained equalities is allowed (e.g. of
  -- three chained equalities: X = Y = Z), but a maximum of one explicit
  -- disequality can appear in a line. All the variables to the left
  -- (resp. right) of the disequality symbol are unified. All the
  -- variables to the left of the disequality symbol are declared
  -- different from all the variables to the right.
  pEqRelations :: Parser (Var -> Formula Filter)
  pEqRelations =     lineAnd <$> pEqualities <*> (pDiseqAndEqs `opt` const Top)
                 <|> pDiseqAndEqs
      where
        pDiseqAndEqs, pEqualities, pEquality :: Parser (Var -> Formula Filter)
        pDiseqAndEqs = diseqAnd <$ pO "/=" <*> pVar <*> (pEqualities `opt` const Top)
        pEqualities  = pO "=" *> (lineAnd <$ pO "=") `pChainr` pEquality
        pEquality    = (:=) <$$> pVar
        diseqAnd :: Var -> (Var -> Formula Filter) -> Var -> Formula Filter
        lineAnd  :: (Var -> Formula Filter) -> (Var -> Formula Filter)
                 ->  Var -> Formula Filter
        diseqAnd varDiseq f varLHS= And (varLHS :≠ varDiseq) (f varDiseq)
        lineAnd f g varLHS = And (f varLHS) (g varLHS)
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptDomain :: Parser (BConcept Domain)
  pConceptDomain =     pIntersection
                   <|> pUnion
      where 
        pIntersection, pUnion, pElemDomain :: Parser (BConcept Domain)
        pElemFilter :: Parser (BConcept Filter)
        pIntersection =   isectD
                          <$> pElemDomain
                          <*  pK "and"
                          <*> (isectF <$ pK "and") `pChainr` pElemFilter
        pUnion      =     (union <$ pK "or") `pChainr` pElemDomain
        pElemDomain =     pDomainId
                      <|> pParens pConceptDomain -- Recursion
        pElemFilter =     rebox <$> pDomainId
                      <|> pFilterId
                      <|> pParens pConceptFilter -- Only dep. with pConceptFilter
                      <|> compl <$ pK "not" <*> pElemFilter -- Recursion
        isectF (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x :⊓ y)
        isectD (MkBConceptDomain x) (MkBConceptFilter y) = MkBConceptDomain (x :⊓ y)
        union  (MkBConceptDomain x) (MkBConceptDomain y) = MkBConceptDomain (x :⊔ y)
        compl  (MkBConceptFilter x)                      = MkBConceptFilter (C x)
        rebox  (MkBConceptDomain x)                      = MkBConceptFilter x
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptFilter :: Parser (BConcept Filter)
  pConceptFilter =     pIntersection
                   <|> pUnion
      where 
        pIntersection, pUnion, pElem :: Parser (BConcept Filter)
        pIntersection = isect
                        <$> pElem
                        <*  pK "and"
                        <*> (isect <$ pK "and") `pChainr` pElem
        pUnion =        (union <$ pK "or") `pChainr` pElem
        pElem  =        rebox <$> pDomainId
                    <|> pFilterId
                    <|> pParens pConceptFilter          -- Recursion
                    <|> compl <$ pK "not" <*> pElem     -- Recursion
        isect (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x :⊓ y)
        union (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x :⊔ y)
        compl (MkBConceptFilter x)                      = MkBConceptFilter (C x)
        rebox (MkBConceptDomain x)                      = MkBConceptFilter x
#+end_src


* Parsers for terminal symbols, lexical analysis

All parsers for terminal symbols are responsible of munching
whitespace after them and take care of possible comments, usually by
means of the =lexeme= parser transformer.

#+begin_src haskell
  -- | Sets indentation at current column and parses @p@ with that
  -- indentation: all tokens in @p@ must start at a grater column than
  -- that indentation, except those marked with @atIndent@, that must
  -- start at this very same column. Token parsers fail if the wrong
  -- indentation is found.
  indented :: ParserTrafo a a
  indented p =
      pSwitch (\old ->
                   (         old {pos = setIndentAtCurrentCol (pos old)}
                   , \new -> new {pos = copyIndent (pos old) (pos new) }
                   )
               ) p
          where
            setIndentAtCurrentCol (LineColPosIndent l c p _) =
                LineColPosIndent l c p c
            copyIndent (LineColPosIndent _ _ _ i) (LineColPosIndent l c p _) =
                LineColPosIndent l c p i
  
  -- | If an indentation has been previously fixed with @indented@,
  -- @atIndent p@ accepts @p@ only if it starts at the very same column
  -- fixed by that indentation.
  atIndent :: ParserTrafo a a
  atIndent p =
      pCheckIndent (==)
      *> pSwitch (\old ->
                      (         old {pos = resetIndent (pos old)         }
                      , \new -> new {pos = copyIndent (pos old) (pos new)}
                      )
                 ) p
          where
            resetIndent (LineColPosIndent l c p _) = LineColPosIndent l c p (-1)
            copyIndent (LineColPosIndent _ _ _ i) (LineColPosIndent l c p _) =
                LineColPosIndent l c p i
  
  pVar :: Parser Var
  pVar = pUpperId
  
  pRoleName :: Parser RoleName
  pRoleName = pLowerId
  
  pRuleSetId :: Parser RuleSetId
  pRuleSetId = pGeneralId
  
  pRuleName :: Parser RuleName
  pRuleName = pGeneralId
  
  -- | At the moment we only support sort names beginning with an upper
  -- case letter (no "_", etc.)
  pDomainId :: Parser (BConcept Domain)
  pDomainId = MkBConceptDomain . D <$> pUpperId
  
  -- | At the moment we only support filter names beginning with a lower
  -- case letter (no "_", etc.)
  pFilterId :: Parser (BConcept Filter)
  pFilterId = MkBConceptFilter . F <$> pLowerId
  
  -- | Parser for keywords.
  pK :: Text -> Parser Text
  pK keyword =
      lexeme $ pToken keyword <* pMaybe (pMunch idChar <* empty)
  
  -- | Parser for operators.
  pO :: Text -> Parser Text
  pO operator =
      lexeme $ pToken operator
  
  pParens :: ParserTrafo a a
  pParens p = lexeme (pSym '(') *> p <* lexeme (pSym ')')
#+end_src

The following functions replace an analogous function in
Text.ParserCombinators.UU.[BasicInstances|Utils]. The original version
works with String, whereas this version has Data.Text in the
signature, but uses String internally. My understanding of
Text.ParserCombinators.UU is that it doesn't support Data.Text at the
low level, as functions like =pToken= and =pMunch= return a list of
something.

#+begin_src haskell
  -- | Replaces @lexeme@ in @Text.ParserCombinators.UU.Utils@. This
  -- version is intended to skip comments, in addition to trailing
  -- whitespace, and supports layout-based (i.e. indentation-based)
  -- parsing.
  lexeme :: ParserTrafo a a
  lexeme p = pCheckIndent (>) *> p <* (pMany pComment <<|> pure [()])
      where pComment =      const () <$ pAnySym (" \r\n\t") <*> pSpaces
                       <<|> pMultilineComment
                       <|>  pOneLineComment
  
  pTokenCost :: Text -> Int -> Parser Text
  pTokenCost tk cost = fromList <$> UU.pTokenCost (toList tk) cost
  
  pToken :: Text -> Parser Text
  pToken tk = pTokenCost tk 5
    
  pMunch :: (Char -> Bool) -> Parser Text
  pMunch pred = fromList <$> UU.pMunch pred
#+end_src

Auxiliary functions.

#+begin_src haskell
  pCheckIndent :: (Int -> Int -> Bool) -> Parser ()
  pCheckIndent comp = pSymExt splitState (Zero Infinite) Nothing
      where
        splitState :: forall st r . (LL.ListLike st Char) =>
                      (() -> (Str Char st LineColPosIndent) -> Steps r)
                          -> (Str Char st LineColPosIndent) -> Steps r
        splitState k inp@(Str tts msgs pos@(LineColPosIndent l c p i) delOk) =
            if c `comp` i
            then k () inp
            else let msg = "or deleted whitespace"
                     ins exp =
                         (3, k () (Str tts (msgs ++ [Inserted msg pos exp]) pos delOk))
                 in Fail ["Different indentation"] [ins]
  
  pLowerId :: Parser Text
  pLowerId = lexeme $ cons <$> pLower <*> pMunch idChar
  
  pUpperId :: Parser Text
  pUpperId = lexeme $ cons <$> pUpper <*> pMunch idChar
  
  pGeneralId :: Parser Text
  pGeneralId = lexeme $ pMunch generalIdChar
      where generalIdChar c = or $ map ($ c) [idChar, (=='.'), (=='-'), (=='/'), (==':')]
  
  idChar :: Char -> Bool
  idChar c = or $ map ($ c) [isAsciiLower, isAsciiUpper, isDigit, (=='\''), (=='_')]
  
  pOneLineComment :: Parser ()
  pOneLineComment = const () <$> pToken "//" <* pMunch (/= '\n')
  
  -- | Any printable symbol is allowed in a multiline comment. No nested
  -- multiline comments are allowed. New lines inside a multiline
  -- comment are not taken into account.
  pMultilineComment :: Parser ()
  pMultilineComment =
      const () <$> pToken "/*" <* pMunch (/= '*') <* pSym '*' <* pAux
      where pAux =      pSym '/'
                   <<|> pMunch (/= '*') *> pSym '*' <* pAux
#+end_src


* File handling

#+begin_src haskell
  translateFile :: String -> IO ()
  translateFile crispFileName = do
    let crispFilePath = OS.decodeString crispFileName
    if crispFilePath `hasExtension` "crisp" then
        do let prologFilePath = crispFilePath `replaceExtension` "pl"
           concreteSyntax <- readFile crispFilePath
           abstractSyntax <- run pModule concreteSyntax
           putStrLn (show abstractSyntax)
           prologCode <-
               do ep <- P.emptyEP
                  ep <- P.addEPCs (map relationToProlog abstractSyntax) ep
                  return $ P.transLloydTopor ep
           writeFile prologFilePath $ P.show prologCode
    else return ()    -- TODO: handle error
#+end_src

#+begin_src haskell
  run :: Parser t -> Text -> IO t
  run p inp =
      do let r@(a, errors) =
                 parse ((,) <$ pSpaces <*> p <*> pEnd) (createStrIndent inp)
             show_errors :: (Show a) => [a] -> IO ()
             show_errors = sequence_ . (map (putStrLn . show))
         -- putStrLn ("--  Result: " ++ show a)
         if null errors then return ()
         else do putStr ("--  Correcting steps: \n")
                 show_errors errors
         return a
#+end_src


* Tests

Load Haskell module, first time.

#+begin_src haskell :var pwd=(pwd) :tangle no :results output silent
  let cd_pwd = return $ ":cd " ++ drop 10 pwd :: IO String
  :cmd cd_pwd
  :cd ..
  :l Crisp.ConcreteSyntax
#+end_src

#+begin_src haskell :tangle no :results output silent
  :set -XOverloadedStrings
  :set -XNoMonomorphismRestriction
  let a = "FunctionDecl   or CXXMethodDecl"
  let b = "  CXXMethodDecl and virtual and abstract"
  let c = "  virtual and CXXMethodDecl and abstract"
  let d = "CXXRecordDecl"
  let e = " (CXXRecordDecl)"
  let f = " (CXXMethodDecl and virtual) or CXXConstructorDecl   "
  let g = "CXXMethodDecl and FunctionDecl or  CXXConstructorDecl"
  let h = "CXXMethodDecl or  FunctionDecl and CXXConstructorDecl"
  putStrLn "OK"
  mapM_ (run pConceptDomain) [a, b,    d, e, f]
  mapM_ (run pConceptFilter) [a, b, c, d, e, f]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [a, b,    d, e, f]
  putStrLn "KO"
  mapM_ (run pConceptDomain) [c, g, h]
  mapM_ (run pConceptFilter) [   g, h]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [c, g, h]
  putStrLn "END"
#+end_src
