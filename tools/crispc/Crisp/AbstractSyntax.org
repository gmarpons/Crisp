# AbstractSyntax.org -----------------------------------------------------------

# Copyright (C) 2011, 2012 Guillem Marpons <gmarpons@babel.ls.fi.upm.es>
#
# This file is part of Crisp.
#
# Crisp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Crisp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Crisp.  If not, see <http://www.gnu.org/licenses/>.

#+PROPERTY: tangle yes
#+PROPERTY: exports code

This is an Org-mode file with Haskell code blocks that can be tangled
(in a literate programming sense) within Emacs with C-c C-v t.

Code blocks in [[*Tests][Tests]] can be loaded and executed in a GHCi session
with C-c C-c.

* Module declaration

#+begin_src haskell
  {-# LANGUAGE 
    ExistentialQuantification,
    FlexibleContexts,
    FlexibleInstances,
    GADTs,
    KindSignatures,
    NoImplicitPrelude,
    OverloadedStrings,
    StandaloneDeriving,
    TypeSynonymInstances,
    UnicodeSyntax
    #-}
  
  module Crisp.AbstractSyntax where
  
  import ClassyPrelude
  import qualified Crisp.PrologSyntax as P
  import qualified Data.NonEmpty as NE
#+end_src


* Operators for Crisp abstract syntax

#+begin_src haskell
  infixl 9 :⊓
  infixl 9 :⊔
  infixl 9 :=
  infixl 9 :≠
#+end_src


* Datatypes for Crisp abstract syntax

This first code block contains some auxiliary type definitions.

#+begin_src haskell
  -- | Class marker used in @BConcept@s and @Formula@s. This class has
  -- two instances: @Domain@ and @Filter@, that are tag types.
  class BM a
  
  -- | Tag type for @BConcept@s defining a search domain, and @Formula@s
  -- defining a binding between a variable and a domain.
  data Domain
  
  -- | Tag type for @Formula@s not defining a binding between a variable
  -- and a domain, and @BConcept@s defining a search filter (instead of
  -- a domain).
  data Filter
  
  instance BM Domain
  instance BM Filter
  
  -- | Class marker used in @Concept@s, for a number of tag types used
  -- to statically compute if a @Concept@ instance can be used as a
  -- search domain or not (i.e., is a filter).
  class                    AM a
  
  data                     C
  data                     D
  data                     F
  
  instance                 AM C   -- Complement
  instance                 AM D   -- Primitive Concept Domain
  instance                 AM F   -- Primitive Concept Filter
  instance (AM a, AM b) => AM (a, b)
  
  -- | Sub-class of @AM@ for types of @Concept@ that can be used as a
  -- search domain.
  class    AM a         => DM a
  instance                 DM D
  instance (DM a, DM b) => DM (a, b)
  
  -- | Boxed concept.
  data BConcept :: * -> * where        
      -- A BConcept contains a 'Concept a', where 'a' is some AM
      -- (existentially quantified in both constructors).
      MkBConceptFilter :: forall a. (AM a, Show (Concept a)) =>
                          Concept a -> BConcept Filter
      MkBConceptDomain :: forall d. (DM d, Show (Concept d)) =>
                          Concept d -> BConcept Domain
  
  deriving instance Show (BConcept c)
#+end_src

Here begins the abstract syntax for Crisp.

#+begin_src haskell
  data Module = Module [Relation]
  
  type OneElemList  = NE.T NE.Empty
  type TwoElemList  = NE.T (NE.T NE.Empty)
  type SomeElemList = NE.T []
  
  type ConceptId = Text
  
  -- | The boolean value states if the word "has" must prepended to the
  -- role name.
  type RoleId = (RoleName, Bool)
  
  type RuleId = (RuleSetId, RuleName)
  
  type RoleName = Text
  
  type RuleName = Text
  
  type RuleSetId = Text
  
  class RelationIdToProlog a where
      idToProlog :: a -> Text
  
  instance RelationIdToProlog ConceptId where
      idToProlog = id
  
  instance RelationIdToProlog RoleId where
      idToProlog (roleName, hasPrefix)
          = if hasPrefix then "has_" ++ roleName else roleName
  
  instance RelationIdToProlog RuleId where
      idToProlog (ruleSetId, ruleName)
          = ruleSetId ++ "::" ++ ruleName
  
  data Relation :: * where
      ConceptDef :: ConceptId -> OneElemList  (Formula Domain) -> Formula Filter -> Relation
      RoleDef    :: RoleId    -> TwoElemList  (Formula Domain) -> Formula Filter -> Relation
      Rule       :: RuleId    -> SomeElemList (Formula Domain) -> Formula Filter -> Relation
#+end_src

Constraints:

- List of =Relation='s of a =Module= is finite.
- All =Relation='s of a =Module= have a different identifier.
- List of =Formula Domain='s in a =Rule= is finite.
- List of =Formula Domain='s in a =Rule= contains at least one element.

#+begin_src haskell
  type Var = Text
  
  -- | A concept assertion contains a true concept definition (that can
  -- be a complex concept referencing both primitive concepts and
  -- user-defined concepts). On the contrary, role assertions do not
  -- allow inline definitions of roles, they only reference a role
  -- (either primitive or user-defined) by its 'RoleId'.
  data Formula :: * -> * where
      ConceptAssert :: (BM b) => Var        -> BConcept b         -> Formula b
      RoleAssert    ::           Var        -> RoleId      -> Var -> Formula Filter
      RoleAssertT   ::           Var        -> RoleId      -> Var -> Formula Filter
      RoleAssertRT  ::           Var        -> RoleId      -> Var -> Formula Filter
      (:=), (:≠)    ::           Var                       -> Var -> Formula Filter
      And, Or       ::           Formula Filter -> Formula Filter -> Formula Filter
      Not           ::           Formula Filter                   -> Formula Filter
      Top           ::                                               Formula Filter
  
  deriving instance Show (Formula a)
#+end_src

Observations:

- The declaration for =data Formula= guarantees that the type parameter
  for =Formula= is always in class =BM= (=BConcept= marker).

#+begin_src haskell
  type DomainId = Text
  
  type FilterId = Text
  
  data Concept :: * -> * where
      D    ::                 DomainId                       -> Concept D
      F    ::                 FilterId                       -> Concept F
      (:⊓) :: (AM a, AM b) => Concept a     -> Concept b     -> Concept a
      (:⊔) :: (AM a, AM b) => Concept a     -> Concept b     -> Concept (a, b)
      C    :: (AM a)       => Concept a                      -> Concept C
  
  deriving instance Show (Concept a)
#+end_src

Observations:

- The declaration for =data Concept= guarantees that the type
  parameter for =Concept= is always in class =AM= ("any" concept
  marker).
- A =Concept d= with =DM d= is a concept that defines a domain for a
  variable (it gives a "type" for that variable). If parameter =d= is
  not in that class (e.g. =Concept F=), then that concept does not
  define a domain, so it cannot be used in contexts where typing a
  variable is mandatory.
- A union of concepts (constructor :⊔) has type parameter in class
  =DM= iff both concepts have its parameter in that class.
- In case of concept intersection (constructor :⊓), the left argument
  determines if the concept parameter is in class =DM= or not, so =D
  "CXXMethodDecl" :⊓ F "virtual"_= has a parameter in =DM= but =F
  "virtual" :⊓ D "CXXMethodDecl"_= does not.


* Translation Crisp AS -> Extended Prolog AS

#+begin_src haskell
  relationToProlog :: Relation -> P.EPC
  relationToProlog = mkEPC
      where 
        mkEPC (ConceptDef id domains filter) = mkEPC' id domains filter
        mkEPC (RoleDef    id domains filter) = mkEPC' id domains filter
        mkEPC (Rule       id domains filter) = mkEPC' id domains filter
        mkEPC' id domains filter
            = P.mkEPC (mkRelationHead id domains) (mkRelationBody domains filter)
        mkRelationHead id domains = P.Atom (idToProlog id) $ fmap P.Var (vars domains)
        mkRelationBody domains filter
            = P.mkConj (NE.toList $ fmap formulaToProlog domains)
              `P.Conj` formulaToProlog filter
        vars domains = NE.toList $ fmap getVar domains
        getVar (ConceptAssert var _) = var
#+end_src

#+begin_src haskell
  formulaToProlog :: Formula f -> P.Formula
  formulaToProlog (ConceptAssert v (MkBConceptDomain c)) = bindingToProlog v c
  formulaToProlog (ConceptAssert v (MkBConceptFilter c)) = bindingToProlog v c
  formulaToProlog (RoleAssert    v1 r v2) = P.At $ P.Atom (idToProlog r)
                                            [P.Var v1, P.Var v2]
  formulaToProlog (RoleAssertT   v1 r v2) = P.At $ mkCallAtom "trans_closure"
                                            [ P.Structure (idToProlog r) []
                                            , P.Var v1, P.Var v2]
  formulaToProlog (RoleAssertRT  v1 r v2) = P.At $ mkCallAtom "refl_trans_closure"
                                            [ P.Structure (idToProlog r) []
                                            , P.Var v1, P.Var v2]
  formulaToProlog (v1 := v2)  = P.At $ mkCallAtom "="   [P.Var v1, P.Var v2]
  formulaToProlog (v1 :≠ v2)  = P.At $ mkCallAtom "\\=" [P.Var v1, P.Var v2]
  formulaToProlog (And e1 e2) = P.Conj (formulaToProlog e1) (formulaToProlog e2)
  formulaToProlog (Or  e1 e2) = P.Disj (formulaToProlog e1) (formulaToProlog e2)
  formulaToProlog (Not e)     = P.Not  (formulaToProlog e)
  formulaToProlog Top         = P.Top
  
  type PredName = Text
  
  mkCallAtom :: PredName -> [P.Term] -> P.Atom
  mkCallAtom p l = P.Atom "call" $ (P.Structure p []) : l
#+end_src

#+begin_src haskell
  bindingToProlog :: forall a. AM a => Var -> Concept a -> P.Formula
  bindingToProlog v (D s)    = P.At $ P.Atom "isA" [P.Var v, P.Structure s []]
  bindingToProlog v (F a)    = P.At $ P.Atom ("is_" ++ a) [P.Var v]
  bindingToProlog v (c1:⊓c2) = P.Conj (bindingToProlog v c1) (bindingToProlog v c2)
  bindingToProlog v (c1:⊔c2) = P.Disj (bindingToProlog v c1) (bindingToProlog v c2)
  bindingToProlog v (C c)    = P.Not  (bindingToProlog v c)
#+end_src


* Tests

Load Haskell module, first time.

#+begin_src haskell :var pwd=(pwd) :tangle no :results output silent
  let cd_pwd = return $ ":cd " ++ drop 10 pwd :: IO String
  :cmd cd_pwd
  :cd ..
  :l Crisp.AbstractSyntax
#+end_src

Evaluate Haskell terms.

#+begin_src haskell :tangle no :results output silent
  :set -XOverloadedStrings
  
  let ca1 = ConceptAssert "Caller" $ MkBConceptDomain (D "CXXMethodDecl")
  let ca2 = ConceptAssert "Callee" $ MkBConceptDomain (D "CXXMethodDecl")
  let ra1 = RoleAssert "Caller" ("functionCall", True) "CallPoint" `And` RoleAssert "CallPoint" ("directCallee", True) "Callee"
  let no1 = Not $ ConceptAssert "Caller" $ MkBConceptFilter (F "virtual")
  formulaToProlog ca1
  formulaToProlog ca2
  formulaToProlog ra1
  formulaToProlog no1
  let pd1 = ConceptDef "caller"            (ca1 NE.!: NE.Empty)           ra1
  let rd1 = RoleDef    ("calls", False)    (ca1 NE.!: ca2 NE.!: NE.Empty) ra1
  let ru1 = Rule       ("HICPP", "3.3.13") (ca1 `NE.cons` NE.Cons ca2 []) ra1
  
  -- Lloyd-topor
  putStrLn "Lloyd-topor: BEGIN"
  prologCode <- do { ep <- P.emptyEP; ep <- P.addEPCs (map relationToProlog [rd1, ru1]) ep; return $ P.transLloydTopor ep }
  P.show prologCode
  putStrLn "END"
#+end_src
