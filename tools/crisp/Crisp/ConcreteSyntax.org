# ConcreteSyntax.org -----------------------------------------------------------

# Copyright (C) 2011, 2012 Guillem Marpons <gmarpons@babel.ls.fi.upm.es>
#
# This file is part of Crisp.
#
# Crisp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Crisp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Crisp.  If not, see <http://www.gnu.org/licenses/>.

#+PROPERTY: tangle yes
#+PROPERTY: exports code

This is an Org-mode file with Haskell code blocks that can be tangled
(in a literate programming sense) within Emacs with C-c C-v t.

Code blocks in [[*Tests][Tests]] can be loaded and executed in a GHCi session
with C-C C-c.

* Module declaration

#+begin_src haskell
  {-# LANGUAGE
    GADTs,
    FlexibleContexts,
    FlexibleInstances,
    MultiParamTypeClasses,
    NoMonomorphismRestriction,
    Rank2Types,
    TypeSynonymInstances
    #-}
  
  module Crisp.ConcreteSyntax where
  
  import Crisp.AbstractSyntax
  import Data.Char
      (isAsciiUpper, isAsciiLower, isDigit)
  import Text.ParserCombinators.UU.BasicInstances
  import Text.ParserCombinators.UU.Core
  import Text.ParserCombinators.UU.Derived
  import Text.ParserCombinators.UU.Utils hiding (pLParen, pRParen, pParens, pSpaces)
#+end_src


* Parsers for non-terminal symbols
  
#+begin_src haskell
  pFormulaDomain :: Parser (Formula Domain)
  pFormulaDomain = ConceptAssert <$> pVar <* pKeyword "is" <*> pConceptDomain
  
  --pFormulaFilter :: Parser (Formula Filter)
  --pFormulaFilter = ConceptAssert <$> pVar <* pKeyword "is" <*> pConceptFilter
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptDomain :: Parser (BConcept Domain)
  pConceptDomain = 
          pIntersection
      <|> pUnion
      where pIntersection, pUnion, pElemDomain :: Parser (BConcept Domain)
            pElemFilter :: Parser (BConcept Filter)
            pIntersection = isectD
                            <$> pElemDomain
                            <*  pKeyword "and"
                            <*> (isectF <$ pKeyword "and") `pChainr` pElemFilter
            pUnion        = (union <$ pKeyword "or") `pChainr` pElemDomain
            pElemDomain =     pDomainId
                          <|> pParens pConceptDomain                  -- Recursion
            pElemFilter =     rebox <$> pDomainId
                          <|> pFilterId
                          <|> pParens pConceptFilter                  -- Only dep. with
                                                                      -- pConceptFilter
                          <|> compl <$ pKeyword "not" <*> pElemFilter -- Recursion
            isectF (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x:⊓y)
            isectD (MkBConceptDomain x) (MkBConceptFilter y) = MkBConceptDomain (x:⊓y)
            union  (MkBConceptDomain x) (MkBConceptDomain y) = MkBConceptDomain (x:⊔y)
            compl  (MkBConceptFilter x)                      = MkBConceptFilter (C x)
            rebox  (MkBConceptDomain x)                      = MkBConceptFilter x
  
  -- | Both 'and' and 'or' are right-associative. Neither one of them
  -- binds stronger than the other, so explicit parenthesizing is needed
  -- to mix them.
  pConceptFilter :: Parser (BConcept Filter)
  pConceptFilter =
          pIntersection
      <|> pUnion
      where pIntersection, pUnion, pElem :: Parser (BConcept Filter)
            pIntersection = isect
                            <$> pElem
                            <*  pKeyword "and"
                            <*> (isect <$ pKeyword "and") `pChainr` pElem
            pUnion        = (union <$ pKeyword "or") `pChainr` pElem
            pElem =     rebox <$> pDomainId
                    <|> pFilterId
                    <|> pParens pConceptFilter            -- Recursion
                    <|> compl <$ pKeyword "not" <*> pElem -- Recursion
            isect (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x:⊓y)
            union (MkBConceptFilter x) (MkBConceptFilter y) = MkBConceptFilter (x:⊔y)
            compl (MkBConceptFilter x)                      = MkBConceptFilter (C x)
            rebox (MkBConceptDomain x)                      = MkBConceptFilter x
#+end_src


* Parsers for terminal symbols, lexical analysis

All parsers for terminal symbols are responsible of munching
whitespace after them and take care of possible comments.

#+begin_src haskell
  pVar :: Parser Var
  pVar = pUpperId
  
  -- | At the moment we only support sort names beginning with an upper
  -- case letter (no "_", etc.)
  pDomainId :: Parser (BConcept Domain)
  pDomainId = MkBConceptDomain . D <$> pUpperId
  
  -- | At the moment we only support adjective names beginning with a lower
  -- case letter (no "_", etc.)
  pFilterId :: Parser (BConcept Filter)
  pFilterId = MkBConceptFilter . F <$> pLowerId
  
  pKeyword :: String -> Parser ()
  pKeyword keyword =
      pTerminal $ const () <$> pToken keyword <* pMaybe (pMunch idChar <* pFail)
  
  pParens :: ParserTrafo a a
  pParens p = pLParen *> p <* pRParen
#+end_src

Auxiliary functions.

#+begin_src haskell
  pTerminal :: ParserTrafo a a
  pTerminal p = p <* pSpaces <* (pComment `opt` ())
      where pComment =     pOneLineComment
                       <|> pMultilineComment
  
  pLParen, pRParen :: Parser ()
  pLParen = pTerminal $ const () <$> pSym '('
  pRParen = pTerminal $ const () <$> pSym ')'
  
  pLowerId :: Parser String
  pLowerId = pTerminal $ (:) <$> pLower <*> pMunch idChar
  
  pUpperId :: Parser String
  pUpperId = pTerminal $ (:) <$> pUpper <*> pMunch idChar
  
  idChar :: Char -> Bool
  idChar c = or $ map ($ c) [isAsciiLower, isAsciiUpper, isDigit, (=='\''), (=='_')]
  
  -- | This parser hides the one in UU.Utils, because in our lexer
  -- newlines are semantically significant and we don't allow tabs
  -- outside comments.
  pSpaces :: Parser ()
  pSpaces = const () <$> pMunch (`elem` " \r") <?> "Whitespace"
  
  pOneLineComment :: Parser ()
  pOneLineComment = const () <$> pToken "--" <* pMunch (/= '\n')
  
  -- | Any printable symbol is allowed in a multiline comment. No nested
  -- multiline comments are allowed. New lines inside a multiline
  -- comment are not taken into account.
  pMultilineComment :: Parser ()
  pMultilineComment =
      const () <$> pToken "{-" <* pMunch (/= '-') <* pSym '-' <* pAux <* pSpaces
      where pAux =      pSym '}'
                   <<|> pMunch (/= '-') *> pSym '-' <* pAux
#+end_src


* File handling

#+begin_src haskell
  -- translateFile :: String -> IO ()
  -- translateFile fileName = do
  --   result <- parseFromFileEx rulesFile fileName
  --   case result of
  --     Failure diags -> unless (Seq.null diags) $ displayLn diags
  --     Success diags translation -> do
  --                            unless (Seq.null diags) $ displayLn diags
  --                            print translation
#+end_src


* Tests

Load Haskell module, first time.

#+begin_src haskell :var pwd=(pwd) :tangle no :results output
  let cd_pwd = return $ ":cd " ++ drop 10 pwd :: IO String
  :cmd cd_pwd
  :cd ..
  :l Crisp.ConcreteSyntax
#+end_src

#+begin_src haskell
  run :: Show t => Parser t -> String -> IO ()
  run p inp =
      do let r@(a, errors) = parse 
                             ((,) <$ pSpaces <*> p <*> pEnd) 
                             (createStr (LineColPos 0 0 0) inp)
         putStrLn ("--  Result: " ++ show a)
         if null errors then return ()
         else do putStr ("--  Correcting steps: \n")
                 show_errors errors
         putStrLn "-- "
      where show_errors :: (Show a) => [a] -> IO ()
            show_errors = sequence_ . (map (putStrLn . show))
  
  pa :: Parser String 
  pa = (:[]) <$> pSym 'a'
#+end_src

#+begin_src haskell :tangle no :results output
  let a = "FunctionDecl   or CXXMethodDecl"
  let b = "  CXXMethodDecl and virtual and abstract"
  let c = "  virtual and CXXMethodDecl and abstract"
  let d = "CXXRecordDecl"
  let e = " (CXXRecordDecl)"
  let f = " (CXXMethodDecl and virtual) or CXXConstructorDecl   "
  let g = "CXXMethodDecl and FunctionDecl or  CXXConstructorDecl"
  let h = "CXXMethodDecl or  FunctionDecl and CXXConstructorDecl"
  putStrLn "OK"
  mapM_ (run pConceptDomain) [a, b,    d, e, f]
  mapM_ (run pConceptFilter) [a, b, c, d, e, f]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [a, b,    d, e, f]
  putStrLn "KO"
  mapM_ (run pConceptDomain) [c, g, h]
  mapM_ (run pConceptFilter) [   g, h]
  mapM_ (run pFormulaDomain) $ map ("X is " ++) [c, g, h]
  putStrLn "END"
#+end_src
