# AbstractSyntax.org -----------------------------------------------------------

# Copyright (C) 2011, 2012 Guillem Marpons <gmarpons@babel.ls.fi.upm.es>
#
# This file is part of Crisp.
#
# Crisp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Crisp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Crisp.  If not, see <http://www.gnu.org/licenses/>.

#+PROPERTY: tangle yes
#+PROPERTY: exports code

This is an Org-mode file with Haskell code blocks that can be tangled
(in a literate programming sense) within Emacs with C-c C-v t.

Code blocks in [[*Tests][Tests]] can be loaded and executed in a GHCi session
with C-C C-c.

* Module declaration

#+begin_src haskell
  {-# LANGUAGE 
    ExistentialQuantification,
    FlexibleContexts,
    GADTs,
    KindSignatures,
    StandaloneDeriving,
    UnicodeSyntax
    #-}
  
  module Crisp.AbstractSyntax
  where
  
  import qualified Crisp.PrologSyntax as P
  import qualified Data.NonEmpty as NE
#+end_src


* Operators for Crisp abstract syntax

#+begin_src haskell
  infixl 9 :⊓
  infixl 9 :⊔
  infixl 9 :=
  infixl 9 :≠
#+end_src


* Datatypes for Crisp abstract syntax

This first code block contains some auxiliary type definitions.

#+begin_src haskell
  -- | Tag type for Concept's defining a sort, and Formula's defining a
  -- binding between a variable and a sort (base case).
  data Sort
  
  -- | Tag type for Formula's not defining a binding between a variable
  -- and a sort.
  data NoSort
  
  -- | Tag type for Concept's not defining a sort (base case).
  data Adj
  
  -- | Tag type for Concept's defined as the complement of another
  -- concept.
  data Compl
    
  -- | Formula marker
  class                    FM a
  instance                 FM Adj
  instance                 FM Compl
  instance                 FM NoSort
  instance                 FM Sort
  instance (FM a, FM b) => FM (a, b)
  
  -- | Primitive concept marker
  class    FM a         => PM a
  instance                 PM Adj
  instance                 PM Sort
    
  -- | Sort marker, to mark formulas that give a sort to some
  -- variable.
  class    FM a         => SM a
  instance                 SM Sort
  instance (SM a, SM b) => SM (a, b)
  
  data FormulaBox :: * where     -- An FormulaBox contains an Formula m,
                                 -- where m is some FM (existentially
                                 -- quantified).
      MkFormulaBox :: forall m. (FM m, Show (Formula m)) => Formula m -> FormulaBox
  
  deriving instance Show FormulaBox
  
  data FormulaSMBox :: * where    -- An FormulaSMBox contains an Formula
                                  -- m, where m is some SM
                                  -- (existentially quantified).
      MkFormulaSMBox :: forall m. (SM m, Show (Formula m)) => Formula m -> FormulaSMBox
  
  deriving instance Show FormulaSMBox
  
  data ConceptBox :: * where      -- A ConceptBox contains a Concept m,
                                  -- where m is some FM (existentially
                                  -- quantified).
      MkConceptBox :: forall m. (FM m, Show (Concept m)) =>
                      Concept m -> ConceptBox
  
  deriving instance Show ConceptBox
  
  data ConceptSMBox :: * where    -- A ConceptSMBox contains a Concept m
                                  -- where m is some SM (existentially
                                  -- quantified).
      MkConceptSMBox :: forall m. (SM m, Show (Concept m)) =>
                        Concept m -> ConceptSMBox
  
  deriving instance Show ConceptSMBox
#+end_src

Here begins the abstract syntax for Crisp.

#+begin_src haskell
  data Module = Module [Relation]
  
  type NonEmptyList = NE.T []
  type OneElemList  = NE.T NE.Empty
  type TwoElemList  = NE.T (NE.T NE.Empty)
  
  type ConceptId = String
  
  -- | The boolean value states if the word "has" must prepended to the
  -- role name.
  type RoleId = (String, Bool)
  
  type RuleId = (RuleSetId, String)
  
  type RuleSetId = String
  
  data Relation where
      ConceptDef :: FM f => ConceptId -> OneElemList  FormulaSMBox -> Formula f -> Relation
      RoleDef    :: FM f => RoleId    -> TwoElemList  FormulaSMBox -> Formula f -> Relation
      Rule       :: FM f => RuleId    -> NonEmptyList FormulaSMBox -> Formula f -> Relation
#+end_src

Constraints:

- List of =Relation='s of a =Module= is finite.
- All =Relation='s of a =Module= have different =RelationId=.
- List of =FormulaSMBox='s in =Rule='s is finite.
- List of =FormulaSMBox='s in =Rule='s contains at least one element.

#+begin_src haskell
  type Var = String
  
  -- | A concept assertion contains a true concept definition (that can
  -- be a complex concept referencing both primitive concepts and
  -- user-defined - with 'ConceptDef'- concepts). On the contrary, role
  -- assertions do not allow inline definitions of roles, they only
  -- reference a role (either primitive or user-defined) by its 'RoleId'.
  data Formula :: * -> * where
      ConceptAssert :: (FM e)       => Var       -> Concept e        -> Formula e
      RoleAssert    ::                 Var       -> RoleId    -> Var -> Formula NoSort
      RoleAssertT   ::                 Var       -> RoleId    -> Var -> Formula NoSort
      RoleAssertRT  ::                 Var       -> RoleId    -> Var -> Formula NoSort
      And           :: (FM e, FM f) => Formula e -> Formula f        -> Formula NoSort
      Or            :: (FM e, FM f) => Formula e -> Formula f        -> Formula NoSort
      Not           :: (FM e)       => Formula e                     -> Formula NoSort
      Top           ::                                                  Formula NoSort
      (:=)          ::                 Var                    -> Var -> Formula NoSort
      (:≠)          ::                 Var                    -> Var -> Formula NoSort
  
  deriving instance Show (Formula a)
#+end_src

Observations:

- The declaration for =data Formula= guarantees that the type parameter
  for =Formula= is always in class =FM= (formula marker).

#+begin_src haskell
  type SortId = String
  
  -- | Adjective id.
  type AdjId = String
  
  data Concept :: * -> * where
      S    ::                 SortId                         -> Concept Sort
      A    ::                 AdjId                          -> Concept Adj
      (:⊓) :: (FM e, FM f) => Concept e     -> Concept f     -> Concept e
      (:⊔) :: (FM e, FM f) => Concept e     -> Concept f     -> Concept (e, f)
      -- C    :: (FM e)       => Concept e                      -> Concept Compl
  
  deriving instance Show (Concept a)
#+end_src

Observations:

- The declaration for =data Concept= guarantees that the type
  parameter for =Concept= is always in class =FM= (Formula marker).
- A =Concept s= with =SM s= (=SM= is class "sort marker") is a concept
  that defines a sort for a variable (it gives a "type" for that
  variable). If parameter =s= is not in that class (e.g. =Concept
  Adj=), then that concept does not define a sort, so it cannot be
  used in contexts where typing a variable is mandatory.
- A union of concepts (constructor :⊔) has type parameter in class
  =SM= iff both concepts have its parameter in that class.
- In case of concept intersection (constructor :⊓), the left argument
  determines if the concept parameter is in class =SM= or not, so =S
  "CXXMethodDecl" :⊓ A "virtual"_= has a parameter in =SM= but =A
  "virtual" :⊓ S "CXXMethodDecl"_= does not.


* Translation Crisp AS -> Extended Prolog AS

#+begin_src haskell
  bindingToProlog :: Var -> Concept c -> P.Formula
  bindingToProlog v (S s)    = P.At $ mkIsAtom v (S s)
  bindingToProlog v (A a)    = P.At $ mkIsAtom v (A a)
  bindingToProlog v (c1:⊓c2) = P.Conj (bindingToProlog v c1) (bindingToProlog v c2)
  bindingToProlog v (c1:⊔c2) = P.Disj (bindingToProlog v c1) (bindingToProlog v c2)
  -- bindingToProlog v (C c)    = P.Not  (bindingToProlog v c)
#+end_src

#+begin_src haskell
  formulaToProlog :: forall f. FM f => Formula f -> P.Formula
  formulaToProlog (ConceptAssert v  c)    = bindingToProlog v c
  formulaToProlog (RoleAssert    v1 r v2) = P.At $ P.Atom (roleIdToProlog r)
                                            [P.Var v1, P.Var v2]
  formulaToProlog (RoleAssertT   v1 r v2) = P.At $ mkCallAtom "trans_closure"
                                            [ P.Structure (roleIdToProlog r) []
                                            , P.Var v1, P.Var v2]
  formulaToProlog (RoleAssertRT  v1 r v2) = P.At $ mkCallAtom "refl_trans_closure"
                                            [ P.Structure (roleIdToProlog r) []
                                            , P.Var v1, P.Var v2]
  formulaToProlog (And e1 e2) = P.Conj (formulaToProlog e1) (formulaToProlog e2)
  formulaToProlog (Or  e1 e2) = P.Disj (formulaToProlog e1) (formulaToProlog e2)
  formulaToProlog (Not e)     = P.Not  (formulaToProlog e)
  formulaToProlog Top         = P.Top
  formulaToProlog (v1 := v2)  = P.At $ mkCallAtom "=" [P.Var v1, P.Var v2]
  formulaToProlog (v1 :≠ v2)  = P.At $ mkCallAtom "\\=" [P.Var v1, P.Var v2]
#+end_src

#+begin_src haskell :tangle no
  topLevelToProlog :: Relation -> P.EPC
  topLevelToProlog (PredIs   id s   es)
      = P.mkEPC (mkHeadFromVars (idForIsRole id) [var s])
        $ mkBody [MkFormulaSMBox s] es
  topLevelToProlog (PredHas  id s t es)
      = P.mkEPC (mkHeadFromVars (idForHasRole id) [var s, var t])
        $ mkBody [MkFormulaSMBox s, MkFormulaSMBox t] es
  topLevelToProlog (Rule set id ss  es) 
      = P.mkEPC (mkRuleHead set id (vars ss)) (mkBody ss es)
#+end_src

Auxiliary definitions in the following code block.

#+begin_src haskell
  type PredName = String
  
  mkIsAtom :: forall p. PM p => Var -> Concept p -> P.Atom
  mkIsAtom v (S s) = P.Atom "is_" [P.Var v, P.Structure s []]
  mkIsAtom v (A a) = P.Atom "is_" [P.Var v, P.Structure a []]
  
  mkCallAtom :: PredName -> [P.Term] -> P.Atom
  mkCallAtom p l = P.Atom "call" $ (P.Structure p []) : l
  
  -- idForIsRole :: Role -> String
  -- idForIsRole = ("is_" ++)
  
  roleIdToProlog :: RoleId -> String
  roleIdToProlog (roleName, hasPrefix)
      = if hasPrefix then "has_" ++ roleName else roleName
  
  mkHeadFromVars :: PredName -> [Var] -> P.Atom
  mkHeadFromVars name vars = P.Atom name $ map P.Var vars
  
  mkRuleHead :: RuleId -> [Var] -> P.Atom
  mkRuleHead (set, id) vars
      = let qualifiedRuleName = set ++ " " ++ id
        in P.Atom "violation" $ (P.Structure qualifiedRuleName []) : map P.Var vars
  
  mkSignature :: [FormulaSMBox] -> P.Formula
  mkSignature bindings = P.mkConj $ map getBind bindings
      where getBind (MkFormulaSMBox se) = formulaToProlog se
  
  mkBody :: FM e => [FormulaSMBox] -> Formula e -> P.Formula
  mkBody signature meet
      = mkSignature signature `P.Conj` formulaToProlog meet
  
  var :: SM s => Formula s -> Var
  var (ConceptAssert v _) = v
  
  vars :: [FormulaSMBox] -> [Var]
  vars = map (\(MkFormulaSMBox e) -> var e)
#+end_src


* Tests

Load Haskell module, first time.

#+begin_src haskell :var pwd=(pwd) :tangle no :results output
  let cd_pwd = return $ ":cd " ++ drop 10 pwd :: IO String
  :cmd cd_pwd
  :cd ..
  :l Crisp.AbstractSyntax
#+end_src

Evaluate Haskell terms.

#+begin_src haskell :tangle no :results output
  :l Crisp.AbstractSyntax
  :t PredHas "functionCall" ("Func" `Is` (S "FunctionDecl")) ("Call" `Is` (S "CallExpr")) ("Func" `Has` "body" $ "Body")
  -- :t Not $ "Caller" `Is` C (A "virtual")
  let a = "Caller" `Is` (S "CXXMethodDecl")
  let b = ("Caller" `Has` "functionCall" $ "CallPoint") `And` ("CallPoint" `Has` "directCallee" $ "Callee")
  formulaToProlog $ Not $ "Caller" `Is` (A "virtual")
  formulaToProlog $ "Body" `HasT` "child" $ "Call"
  let p1 = PredHas "functionCall" ("Func" `Is` S "FunctionDecl") ("Call" `Is` S "CallExpr") (("Func" `Has` "body" $ "Body") `And` ("Body" `HasT` "child" $ "Call"))
  let p2 = PredHas "callee" ("Caller" `Is` S "FunctionDecl") ("Callee" `Is` S "FunctionDecl") (("Caller" `Has` "functionCall" $ "CallPoint") `And` ("CallPoint" `Has` "directCallee" $ "Callee"))
  let r1 = Rule "HICPP" "3.3.13" [MkFormulaSMBox $ "Caller" `Is` S "FunctionDecl", MkFormulaSMBox $ "Caller" `Is` S "FunctionDecl"] (("Record" `Is` S "CXXRecordDecl") `And` (("Record" `Has` "ctor" $ "Caller") `Or`("Record" `Has` "destructor" $ "Caller")) `And` ("Record" `Has` "method" $ "Callee") `And` ("Callee" `Is` A "virtual"))
  -- Lloyd-topor
  putStrLn ""
  do { ep <- P.emptyEP; ep <- P.addEPCs (map topLevelToProlog [p1, p2, r1]) ep; return $ P.transLloydTopor ep }
  putStrLn "END"
#+end_src
