# AbstractSyntax.org -----------------------------------------------------------

# Copyright (C) 2011, 2012 Guillem Marpons <gmarpons@babel.ls.fi.upm.es>
#
# This file is part of Crisp.
#
# Crisp is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Crisp is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Crisp.  If not, see <http://www.gnu.org/licenses/>.

#+PROPERTY: tangle yes
#+PROPERTY: exports code

This is an Org-mode file with Haskell code blocks that can be tangled
(in a literate programming sense) within Emacs with C-c C-v t.

Code blocks in [[*Tests][Tests]] can be loaded and executed in a GHCi session
with C-C C-c.

* Module declaration

#+begin_src haskell
  {-# LANGUAGE 
    ExistentialQuantification,
    FlexibleContexts,
    GADTs,
    KindSignatures,
    StandaloneDeriving,
    UnicodeSyntax
    #-}
  
  module Crisp.AbstractSyntax
  where
  
  import qualified Crisp.PrologSyntax as P
  import qualified Data.NonEmpty as NE
#+end_src


* Operators for Crisp abstract syntax

#+begin_src haskell
  infixl 9 :⊓
  infixl 9 :⊔
  infixl 9 :=
  infixl 9 :≠
#+end_src


* Datatypes for Crisp abstract syntax

This first code block contains some auxiliary type definitions.

#+begin_src haskell
  -- | Class marker used in @BConcept@s and @Formula@s. This class has
  -- two instances: @Domain@ and @Filter@, that are tag types.
  class BM a
  
  -- | Tag type for @BConcept@s defining a search domain, and @Formula@s
  -- defining a binding between a variable and a domain.
  data Domain
  
  -- | Tag type for @Formula@s not defining a binding between a variable
  -- and a domain, and @BConcept@s defining a search filter (instead of
  -- a domain).
  data Filter
  
  instance BM Domain
  instance BM Filter
  
  -- | Class marker used in @Concept@s, for a number of tag types used
  -- to statically compute if a @Concept@ instance can be used as a
  -- search domain or not (i.e., is a filter).
  class                    AM a
  
  data                     C
  data                     D
  data                     F
  
  instance                 AM C
  instance                 AM D
  instance                 AM F
  instance (AM a, AM b) => AM (a, b)
  
  -- | Sub-class of @AM@ for types of @Concept@ that can be used as a
  -- search domain.
  class    AM a         => DM a
  instance                 DM D
  instance (DM a, DM b) => DM (a, b)
  
  -- | Boxed concept.
  data BConcept :: * -> * where        
      -- A BConcept contains a 'Concept a', where 'a' is some AM
      -- (existentially quantified in both constructors).
      MkBConceptFilter :: forall a. (AM a, Show (Concept a)) =>
                          Concept a -> BConcept Filter
      MkBConceptDomain :: forall d. (DM d, Show (Concept d)) =>
                          Concept d -> BConcept Domain
  
  deriving instance Show (BConcept c)
#+end_src

Here begins the abstract syntax for Crisp.

#+begin_src haskell
  data Module = Module [Relation]
  
  type NonEmptyList = NE.T []
  type OneElemList  = NE.T NE.Empty
  type TwoElemList  = NE.T (NE.T NE.Empty)
  
  type ConceptId = String
  
  -- | The boolean value states if the word "has" must prepended to the
  -- role name.
  type RoleId = (String, Bool)
  
  type RuleId = (RuleSetId, String)
  
  type RuleSetId = String
  
  data Relation :: * where
      ConceptDef :: ConceptId -> OneElemList  (Formula Domain) -> Formula Filter -> Relation
      RoleDef    :: RoleId    -> TwoElemList  (Formula Domain) -> Formula Filter -> Relation
      Rule       :: RuleId    -> NonEmptyList (Formula Domain) -> Formula Filter -> Relation
#+end_src

Constraints:

- List of =Relation='s of a =Module= is finite.
- All =Relation='s of a =Module= have a different identifier.
- List of =Formula Domain='s in a =Rule= is finite.
- List of =Formula Domain='s in a =Rule= contains at least one element.

#+begin_src haskell
  type Var = String
  
  -- | A concept assertion contains a true concept definition (that can
  -- be a complex concept referencing both primitive concepts and
  -- user-defined concepts). On the contrary, role assertions do not
  -- allow inline definitions of roles, they only reference a role
  -- (either primitive or user-defined) by its 'RoleId'.
  data Formula :: * -> * where
      ConceptAssert :: (BM b) => Var        -> BConcept b         -> Formula b
      RoleAssert    ::           Var        -> RoleId      -> Var -> Formula Filter
      RoleAssertT   ::           Var        -> RoleId      -> Var -> Formula Filter
      RoleAssertRT  ::           Var        -> RoleId      -> Var -> Formula Filter
      (:=)          ::           Var                       -> Var -> Formula Filter
      (:≠)          ::           Var                       -> Var -> Formula Filter
      And           ::           Formula Filter -> Formula Filter -> Formula Filter
      Or            ::           Formula Filter -> Formula Filter -> Formula Filter
      Not           ::           Formula Filter                   -> Formula Filter
      Top           ::                                               Formula Filter
  
  deriving instance Show (Formula a)
#+end_src

Observations:

- The declaration for =data Formula= guarantees that the type parameter
  for =Formula= is always in class =BM= (=BConcept= marker).

#+begin_src haskell
  type DomainId = String
  
  type FilterId = String
  
  data Concept :: * -> * where
      D    ::                 DomainId                       -> Concept D
      F    ::                 FilterId                       -> Concept F
      (:⊓) :: (AM a, AM b) => Concept a     -> Concept b     -> Concept a
      (:⊔) :: (AM a, AM b) => Concept a     -> Concept b     -> Concept (a, b)
      C    :: (AM a)       => Concept a                      -> Concept C
  
  deriving instance Show (Concept a)
#+end_src

Observations:

- The declaration for =data Concept= guarantees that the type
  parameter for =Concept= is always in class =AM= ("any" concept
  marker).
- A =Concept d= with =DM d= is a concept that defines a domain for a
  variable (it gives a "type" for that variable). If parameter =d= is
  not in that class (e.g. =Concept F=), then that concept does not
  define a domain, so it cannot be used in contexts where typing a
  variable is mandatory.
- A union of concepts (constructor :⊔) has type parameter in class
  =DM= iff both concepts have its parameter in that class.
- In case of concept intersection (constructor :⊓), the left argument
  determines if the concept parameter is in class =DM= or not, so =D
  "CXXMethodDecl" :⊓ F "virtual"_= has a parameter in =DM= but =F
  "virtual" :⊓ D "CXXMethodDecl"_= does not.


* Translation Crisp AS -> Extended Prolog AS

#+begin_src haskell
  bindingToProlog :: forall a. AM a => Var -> Concept a -> P.Formula
  bindingToProlog v (D s)    = P.At $ P.Atom "isA" [P.Var v, P.Structure s []]
  bindingToProlog v (F a)    = P.At $ P.Atom ("is_" ++ a) [P.Var v]
  bindingToProlog v (c1:⊓c2) = P.Conj (bindingToProlog v c1) (bindingToProlog v c2)
  bindingToProlog v (c1:⊔c2) = P.Disj (bindingToProlog v c1) (bindingToProlog v c2)
  bindingToProlog v (C c)    = P.Not  (bindingToProlog v c)
#+end_src

#+begin_src haskell :tangle no
  formulaToProlog :: Formula f -> P.Formula
  formulaToProlog (ConceptAssert v (MkBConceptDomain c)) = bindingToProlog v c
  formulaToProlog (ConceptAssert v (MkBConceptFilter c)) = bindingToProlog v c
  formulaToProlog (RoleAssert    v1 r v2) = P.At $ P.Atom (roleIdToProlog r)
                                            [P.Var v1, P.Var v2]
  formulaToProlog (RoleAssertT   v1 r v2) = P.At $ mkCallAtom "trans_closure"
                                            [ P.Structure (roleIdToProlog r) []
                                            , P.Var v1, P.Var v2]
  formulaToProlog (RoleAssertRT  v1 r v2) = P.At $ mkCallAtom "refl_trans_closure"
                                            [ P.Structure (roleIdToProlog r) []
                                            , P.Var v1, P.Var v2]
  formulaToProlog (v1 := v2)  = P.At $ mkCallAtom "="   [P.Var v1, P.Var v2]
  formulaToProlog (v1 :≠ v2)  = P.At $ mkCallAtom "\\=" [P.Var v1, P.Var v2]
  formulaToProlog (And e1 e2) = P.Conj (formulaToProlog e1) (formulaToProlog e2)
  formulaToProlog (Or  e1 e2) = P.Disj (formulaToProlog e1) (formulaToProlog e2)
  formulaToProlog (Not e)     = P.Not  (formulaToProlog e)
  formulaToProlog Top         = P.Top

  type PredName = String
  
  mkCallAtom :: PredName -> [P.Term] -> P.Atom
  mkCallAtom p l = P.Atom "call" $ (P.Structure p []) : l
  
  roleIdToProlog :: RoleId -> String
  roleIdToProlog (roleName, hasPrefix)
      = if hasPrefix then "has_" ++ roleName else roleName
#+end_src

#+begin_src haskell :tangle no
  topLevelToProlog :: Relation -> P.EPC
  topLevelToProlog (PredIs   id s   es)
      = P.mkEPC (mkHeadFromVars (idForIsRole id) [var s])
        $ mkBody [MkFormulaDMBox s] es
  topLevelToProlog (PredHas  id s t es)
      = P.mkEPC (mkHeadFromVars (idForHasRole id) [var s, var t])
        $ mkBody [MkFormulaDMBox s, MkFormulaDMBox t] es
  topLevelToProlog (Rule set id ss  es) 
      = P.mkEPC (mkRuleHead set id (vars ss)) (mkBody ss es)
#+end_src

Auxiliary definitions in the following code block.

#+begin_src haskell :tangle no
  mkHeadFromVars :: PredName -> [Var] -> P.Atom
  mkHeadFromVars name vars = P.Atom name $ map P.Var vars
  
  mkRuleHead :: RuleId -> [Var] -> P.Atom
  mkRuleHead (set, id) vars
      = let qualifiedRuleName = set ++ " " ++ id
        in P.Atom "violation" $ (P.Structure qualifiedRuleName []) : map P.Var vars
  
  mkSignature :: [FormulaDMBox] -> P.Formula
  mkSignature bindings = P.mkConj $ map getBind bindings
      where getBind (MkFormulaDMBox se) = formulaToProlog se
  
  mkBody :: FM e => [FormulaDMBox] -> Formula e -> P.Formula
  mkBody signature meet
      = mkSignature signature `P.Conj` formulaToProlog meet
  
  var :: DM d => Formula d -> Var
  var (ConceptAssert v _) = v
  
  vars :: [FormulaDMBox] -> [Var]
  vars = map (\(MkFormulaDMBox e) -> var e)
#+end_src


* Tests

Load Haskell module, first time.

#+begin_src haskell :var pwd=(pwd) :tangle no :results output
  let cd_pwd = return $ ":cd " ++ drop 10 pwd :: IO String
  :cmd cd_pwd
  :cd ..
  :l Crisp.AbstractSyntax
#+end_src

Evaluate Haskell terms.

#+begin_src haskell :tangle no :results output
  :l Crisp.AbstractSyntax
  -- :t PredHas "functionCall" ("Func" `Is` (S "FunctionDecl")) ("Call" `Is` (S "CallExpr")) ("Func" `Has` "body" $ "Body")
  -- :t Not $ "Caller" `Is` C (A "virtual")
  let a = "Caller" `Is` (S "CXXMethodDecl")
  let b = ("Caller" `Has` "functionCall" $ "CallPoint") `And` ("CallPoint" `Has` "directCallee" $ "Callee")
  formulaToProlog $ Not $ "Caller" `Is` (A "virtual")
  formulaToProlog $ "Body" `HasT` "child" $ "Call"
  let p1 = PredHas "functionCall" ("Func" `Is` D "FunctionDecl") ("Call" `Is` D "CallExpr") (("Func" `Has` "body" $ "Body") `And` ("Body" `HasT` "child" $ "Call"))
  let p2 = PredHas "callee" ("Caller" `Is` D "FunctionDecl") ("Callee" `Is` D "FunctionDecl") (("Caller" `Has` "functionCall" $ "CallPoint") `And` ("CallPoint" `Has` "directCallee" $ "Callee"))
  let r1 = Rule "HICPP" "3.3.13" [MkFormulaDMBox $ "Caller" `Is` D "FunctionDecl", MkFormulaDMBox $ "Caller" `Is` D "FunctionDecl"] (("Record" `Is` D "CXXRecordDecl") `And` (("Record" `Has` "ctor" $ "Caller") `Or`("Record" `Has` "destructor" $ "Caller")) `And` ("Record" `Has` "method" $ "Callee") `And` ("Callee" `Is` F "virtual"))
  -- Lloyd-topor
  putStrLn ""
  do { ep <- P.emptyEP; ep <- P.addEPCs (map topLevelToProlog [p1, p2, r1]) ep; return $ P.transLloydTopor ep }
  putStrLn "END"
#+end_src
